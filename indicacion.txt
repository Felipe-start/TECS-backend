ayudame con mi trabajo estoy trabajando con angular es el frotend,node es el backend, mysql que es mi base de datos todo desto desde github codespace,
quiero que me ayudes a complementar lo que me pidio mi profesor que hiciera mi sistema de registro de tecs, que cada tec tubiera sus instituciones adcuadas, que pueda descargar en html el contenido y las graficas poque las carreras deben tener problacion egistrada y esperada,poder subir archivos excel ya con las carreras que tengo y solo subirlas.
ademas de que tubiera dos tipos de usuarios el admin que puede ver todos los tecs, edittar,eliminar, crear usuarios normales o mas admin, osea el admin puede ver todo .
pero el usuario normal solamente puede ver el tec que registro o el suyo y las carreras que le pertenesen y eliminar,consultar,dar de alta igual todo lo del admin pero solamente no ver los otros tecs solamente el suyo 
todo esto utilizando lo antes mencionado y esto es lo que llevo y ayudame a complementarlo par que ya este completo, segun yo ya tengo completa la base de datos y ya le hice unos cambios de datos del tamano de los logos o avatar para que funcionara

mi backend
base de datos
DROP DATABASE IF EXISTS sistema_tec;
CREATE DATABASE sistema_tec;
USE sistema_tec;
CREATE TABLE IF NOT EXISTS users (id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) NOT NULL, email VARCHAR(150) UNIQUE NOT NULL, password VARCHAR(255) NOT NULL, role ENUM('admin','user') DEFAULT 'user', nombre_completo VARCHAR(200), telefono VARCHAR(20), institucion VARCHAR(200), avatar TEXT, numero_trabajador VARCHAR(50), is_active TINYINT(1) DEFAULT 1, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, INDEX idx_email(email), INDEX idx_role(role), INDEX idx_active(is_active)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS institutions (id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, nombre VARCHAR(200) NOT NULL, clave_cct VARCHAR(50) UNIQUE NOT NULL, telefono VARCHAR(20), extension VARCHAR(10), correo VARCHAR(150), nombre_representante VARCHAR(200), puesto_representante VARCHAR(100), direccion TEXT, logo TEXT, estado ENUM('active','inactive') DEFAULT 'active', created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE, INDEX idx_user_id(user_id), INDEX idx_clave_cct(clave_cct), INDEX idx_estado(estado)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS careers (id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, nombre VARCHAR(200) NOT NULL, numero_carrera VARCHAR(50) UNIQUE NOT NULL, cantidad_alumnos INT DEFAULT 0, duracion_semestres INT DEFAULT 8, modalidad ENUM('Escolarizada','Mixta','Virtual') DEFAULT 'Escolarizada', turno ENUM('Matutino','Vespertino','Nocturno','Mixto') DEFAULT 'Matutino', fecha_registro DATE, descripcion TEXT, activa TINYINT(1) DEFAULT 1, poblacion_esperada INT DEFAULT 0, poblacion_real INT DEFAULT 0, logo TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE, INDEX idx_user_id(user_id), INDEX idx_numero_carrera(numero_carrera), INDEX idx_activa(activa)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE IF NOT EXISTS institution_careers (id INT PRIMARY KEY AUTO_INCREMENT, institution_id INT NOT NULL, career_id INT NOT NULL, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (institution_id) REFERENCES institutions(id) ON DELETE CASCADE, FOREIGN KEY (career_id) REFERENCES careers(id) ON DELETE CASCADE, UNIQUE KEY unique_institution_career(institution_id, career_id), INDEX idx_institution_id(institution_id), INDEX idx_career_id(career_id)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
INSERT INTO users (username,email,password,role,nombre_completo,telefono,institucion,numero_trabajador) VALUES ('admin','admin@tec.com','1234','admin','Administrador del Sistema','555-1234','Tecnol√≥gico Nacional','EMP001'), ('user','user@tec.com','1234','user','Usuario de Prueba','555-5678','TEC Campus Centro',NULL);
INSERT INTO institutions (user_id,nombre,clave_cct,telefono,correo,nombre_representante,puesto_representante,direccion,estado) VALUES (1,'Tecnol√≥gico Nacional de M√©xico','CCT001','555-1000','contacto@tecnm.mx','Dr. Juan P√©rez','Director General','Av. Universidad 1000, CDMX','active'), (2,'TEC Campus Centro','CCT002','555-2000','info@teccentro.edu.mx','Ing. Mar√≠a Garc√≠a','Directora','Calle Central 200, Centro','active'), (1,'TEC Campus Norte','CCT003','555-3000','contacto@tecnorte.edu.mx','Lic. Roberto S√°nchez','Director','Blvd. Norte 300, Zona Industrial','active');
INSERT INTO careers (user_id,nombre,numero_carrera,cantidad_alumnos,duracion_semestres,modalidad,turno,fecha_registro,descripcion,activa) VALUES (1,'Ingenier√≠a en Sistemas Computacionales','ISC-001',150,9,'Escolarizada','Matutino','2024-01-15','Carrera enfocada en desarrollo de software y redes',1), (1,'Ingenier√≠a Industrial','IND-002',120,9,'Escolarizada','Matutino','2024-01-15','Optimizaci√≥n de procesos industriales',1), (2,'Licenciatura en Administraci√≥n','LAD-003',100,8,'Mixta','Vespertino','2024-01-15','Gesti√≥n empresarial y administrativa',1), (2,'Ingenier√≠a en Mecatr√≥nica','IME-004',80,10,'Escolarizada','Matutino','2024-01-15','Integraci√≥n de mec√°nica, electr√≥nica y computaci√≥n',1);
INSERT INTO institution_careers (institution_id,career_id) VALUES (1,1),(1,2),(1,3),(2,1),(2,4),(3,2),(3,3);
DELIMITER //;
CREATE PROCEDURE GetSystemStatistics() BEGIN SELECT (SELECT COUNT(*) FROM users) AS total_users, (SELECT COUNT(*) FROM users WHERE role='admin') AS admin_users, (SELECT COUNT(*) FROM users WHERE role='user') AS normal_users, (SELECT COUNT(*) FROM users WHERE is_active=1) AS active_users; SELECT (SELECT COUNT(*) FROM institutions) AS total_institutions, (SELECT COUNT(*) FROM institutions WHERE estado='active') AS active_institutions; SELECT (SELECT COUNT(*) FROM careers) AS total_careers, (SELECT COUNT(*) FROM careers WHERE activa=1) AS active_careers, (SELECT SUM(cantidad_alumnos) FROM careers) AS total_alumnos; END //;
DELIMITER ;
CREATE VIEW vw_institutions_with_careers AS SELECT i.id, i.nombre AS institucion, i.clave_cct, i.estado, u.username AS propietario, COUNT(ic.career_id) AS total_carreras, GROUP_CONCAT(c.nombre SEPARATOR ', ') AS carreras FROM institutions i LEFT JOIN users u ON i.user_id=u.id LEFT JOIN institution_careers ic ON i.id=ic.institution_id LEFT JOIN careers c ON ic.career_id=c.id GROUP BY i.id, i.nombre, i.clave_cct, i.estado, u.username;
CREATE VIEW vw_careers_by_user AS SELECT c.id, c.nombre AS carrera, c.numero_carrera, c.modalidad, c.turno, c.activa, u.username AS propietario, u.email FROM careers c LEFT JOIN users u ON c.user_id=u.id ORDER BY c.created_at DESC;
DELIMITER //;
CREATE TRIGGER tr_update_institution_timestamp BEFORE UPDATE ON institutions FOR EACH ROW BEGIN SET NEW.updated_at=CURRENT_TIMESTAMP; END //;
CREATE TRIGGER tr_update_career_timestamp BEFORE UPDATE ON careers FOR EACH ROW BEGIN SET NEW.updated_at=CURRENT_TIMESTAMP; END //;
CREATE TRIGGER tr_update_user_timestamp BEFORE UPDATE ON users FOR EACH ROW BEGIN SET NEW.updated_at=CURRENT_TIMESTAMP; END //;
CREATE TRIGGER tr_check_user_institution_limit BEFORE INSERT ON institutions FOR EACH ROW BEGIN DECLARE user_role VARCHAR(10); DECLARE institution_count INT; SELECT role INTO user_role FROM users WHERE id=NEW.user_id; IF user_role='user' THEN SELECT COUNT(*) INTO institution_count FROM institutions WHERE user_id=NEW.user_id; IF institution_count>=1 THEN SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT='Los usuarios normales solo pueden tener una instituci√≥n'; END IF; END IF; END //;
DELIMITER ;
CREATE INDEX idx_institutions_user_estado ON institutions(user_id,estado);
CREATE INDEX idx_careers_user_activa ON careers(user_id,activa);
CREATE INDEX idx_users_created ON users(created_at);
CREATE INDEX idx_institutions_created ON institutions(created_at);
CREATE INDEX idx_careers_created ON careers(created_at);
SELECT 'Base de datos creada exitosamente' AS mensaje;

const mysql = require('mysql2');

const db = mysql.createConnection({
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '1234',
    database: process.env.DB_NAME || 'sistema_tec',
    port: 3306,
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
});

// Manejar errores de conexi√≥n
db.connect((err) => {
    if (err) {
        console.error('‚ùå Error conectando a MySQL:', err);
        console.log('Intentando reconectar en 5 segundos...');
        setTimeout(() => db.connect(), 5000);
        return;
    }
    console.log('‚úÖ Conectado a MySQL');
});

// Manejar errores despu√©s de la conexi√≥n
db.on('error', (err) => {
    console.error('‚ùå Error en conexi√≥n MySQL:', err);
    if (err.code === 'PROTOCOL_CONNECTION_LOST') {
        console.log('Reconectando a MySQL...');
        db.connect();
    } else {
        throw err;
    }
});

module.exports = db;
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const db = require('../config/database');

class AuthController {
    // ‚úÖ REGISTRO - M√©todo principal
    static async register(req, res) {
        try {
            const { 
                email, 
                password, 
                nombreCompleto, 
                telefono, 
                institucion,
                username 
            } = req.body;
            
            console.log('üìù Datos de registro recibidos:', req.body);
            
            // Validaciones b√°sicas
            if (!email || !password || !nombreCompleto) {
                return res.status(400).json({
                    success: false,
                    message: 'Email, contrase√±a y nombre son requeridos'
                });
            }
            
            // Verificar si el email ya existe
            const [existing] = await db.promise().query(
                'SELECT id FROM users WHERE email = ?',
                [email]
            );
            
            if (existing.length > 0) {
                return res.status(400).json({
                    success: false,
                    message: 'El email ya est√° registrado'
                });
            }
            
            // Generar username si no viene
            const finalUsername = username || email.split('@')[0];
            
            // Hash de la contrase√±a
            const hashedPassword = await bcrypt.hash(password, 10);
            
            // Insertar usuario
            const [result] = await db.promise().query(
                `INSERT INTO users (username, email, password, nombre_completo, telefono, institucion, role) 
                 VALUES (?, ?, ?, ?, ?, ?, 'user')`,
                [finalUsername, email, hashedPassword, nombreCompleto, telefono, institucion]
            );
            
            console.log('‚úÖ Usuario insertado, ID:', result.insertId);
            
            // Obtener usuario creado
            const [newUser] = await db.promise().query(
                'SELECT * FROM users WHERE id = ?',
                [result.insertId]
            );
            
            // Generar token autom√°ticamente despu√©s del registro
            const token = jwt.sign(
                { 
                    userId: newUser[0].id,
                    email: newUser[0].email,
                    role: newUser[0].role,
                    username: newUser[0].username,
                    nombreCompleto: newUser[0].nombre_completo,
                    institucion: newUser[0].institucion || null
                },
                process.env.JWT_SECRET || 'clave_simple_tec_2024',
                { expiresIn: '8h' }
            );
            
            res.status(201).json({
                success: true,
                message: 'Usuario registrado exitosamente',
                token: token,
                user: {
                    id: newUser[0].id,
                    username: newUser[0].username,
                    email: newUser[0].email,
                    role: newUser[0].role,
                    nombreCompleto: newUser[0].nombre_completo || '',
                    telefono: newUser[0].telefono || '',
                    institucion: newUser[0].institucion || '',
                    avatar: newUser[0].avatar || null
                }
            });
            
        } catch (error) {
            console.error('‚ùå Error en registro:', error);
            res.status(500).json({
                success: false,
                message: 'Error en el servidor',
                error: process.env.NODE_ENV === 'development' ? error.message : undefined
            });
        }
    }

    // ‚úÖ LOGIN - M√©todo actualizado
    static async login(req, res) {
        try {
            const { email, password } = req.body;
            
            console.log('üîê Intento de login para:', email);
            
            if (!email || !password) {
                return res.status(400).json({
                    success: false,
                    message: 'Email y contrase√±a requeridos'
                });
            }
            
            // Buscar usuario
            const [users] = await db.promise().query(
                'SELECT * FROM users WHERE email = ?',
                [email]
            );
            
            if (users.length === 0) {
                console.log('‚ùå Usuario no encontrado:', email);
                return res.status(401).json({
                    success: false,
                    message: 'Credenciales inv√°lidas'
                });
            }
            
            const user = users[0];
            console.log('üë§ Usuario encontrado:', user.id, user.email);
            
            // Verificar contrase√±a
            let isValidPassword = false;
            
            try {
                // Intentar con bcrypt primero
                isValidPassword = await bcrypt.compare(password, user.password);
                
                // Si falla bcrypt pero la contrase√±a coincide directamente (para migraci√≥n)
                if (!isValidPassword && password === user.password) {
                    console.log('‚ö†Ô∏è Usando contrase√±a sin hash (migraci√≥n)');
                    isValidPassword = true;
                    
                    // Actualizar a hash bcrypt
                    const hashedPassword = await bcrypt.hash(password, 10);
                    await db.promise().query(
                        'UPDATE users SET password = ? WHERE id = ?',
                        [hashedPassword, user.id]
                    );
                    console.log('‚úÖ Contrase√±a actualizada a hash bcrypt');
                }
            } catch (bcryptError) {
                console.error('‚ùå Error en bcrypt:', bcryptError);
                // Si hay error en bcrypt, intentar comparaci√≥n directa
                isValidPassword = (password === user.password);
            }
            
            if (!isValidPassword) {
                console.log('‚ùå Contrase√±a incorrecta para:', email);
                return res.status(401).json({
                    success: false,
                    message: 'Credenciales inv√°lidas'
                });
            }
            
            // Generar token
            const token = jwt.sign(
                { 
                    userId: user.id,
                    email: user.email,
                    role: user.role,
                    username: user.username,
                    nombreCompleto: user.nombre_completo,
                    institucion: user.institucion || null
                },
                process.env.JWT_SECRET || 'clave_simple_tec_2024',
                { expiresIn: '8h' }
            );
            
            console.log('‚úÖ Login exitoso, token generado para:', user.email);
            
            // Enviar respuesta
            res.json({
                success: true,
                message: 'Login exitoso',
                token: token,
                user: {
                    id: user.id,
                    username: user.username,
                    email: user.email,
                    role: user.role,
                    nombreCompleto: user.nombre_completo || '',
                    telefono: user.telefono || '',
                    institucion: user.institucion || '',
                    avatar: user.avatar || null
                }
            });
            
        } catch (error) {
            console.error('‚ùå Error en login:', error);
            res.status(500).json({
                success: false,
                message: 'Error en el servidor',
                error: process.env.NODE_ENV === 'development' ? error.message : undefined
            });
        }
    }

    // ‚úÖ PERFIL DEL USUARIO
    static async getProfile(req, res) {
        try {
            const userId = req.user.userId;
            
            const [rows] = await db.promise().query(
                'SELECT * FROM users WHERE id = ?',
                [userId]
            );
            
            if (rows.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            const user = rows[0];
            res.json({
                success: true,
                user: {
                    id: user.id,
                    username: user.username,
                    email: user.email,
                    role: user.role,
                    nombreCompleto: user.nombre_completo || '',
                    telefono: user.telefono || '',
                    institucion: user.institucion || '',
                    avatar: user.avatar || null
                }
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo perfil:', error);
            res.status(500).json({
                success: false,
                message: 'Error en el servidor'
            });
        }
    }

    // ‚úÖ VERIFICAR TOKEN
    static async verify(req, res) {
        try {
            const userId = req.user.userId;
            
            const [rows] = await db.promise().query(
                'SELECT * FROM users WHERE id = ?',
                [userId]
            );
            
            if (rows.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            const user = rows[0];
            res.json({
                success: true,
                user: {
                    id: user.id,
                    username: user.username,
                    email: user.email,
                    role: user.role,
                    nombreCompleto: user.nombre_completo || '',
                    telefono: user.telefono || '',
                    institucion: user.institucion || '',
                    avatar: user.avatar || null
                }
            });
            
        } catch (error) {
            console.error('‚ùå Error verificando token:', error);
            res.status(500).json({
                success: false,
                message: 'Error en el servidor'
            });
        }
    }

    // ‚úÖ OBTENER TODOS LOS USUARIOS (solo admin)
    static async getAllUsers(req, res) {
        try {
            const [users] = await db.promise().query(
                'SELECT id, username, email, role, nombre_completo, telefono, institucion, created_at FROM users ORDER BY created_at DESC'
            );
            
            res.json({
                success: true,
                users: users,
                count: users.length
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo usuarios:', error);
            res.status(500).json({
                success: false,
                message: 'Error en el servidor'
            });
        }
    }

    // ‚úÖ ACTUALIZAR PERFIL DEL USUARIO
    static async updateProfile(req, res) {
        try {
            const userId = req.user.userId;
            const { 
                username, 
                email, 
                nombreCompleto, 
                telefono, 
                institucion,
                avatar 
            } = req.body;
            
            console.log('üìù Actualizando perfil para usuario ID:', userId);
            console.log('üìã Datos recibidos:', req.body);
            
            // Verificar si el usuario existe
            const [users] = await db.promise().query(
                'SELECT * FROM users WHERE id = ?',
                [userId]
            );
            
            if (users.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            // Verificar si el email ya existe (si se est√° cambiando)
            if (email && email !== users[0].email) {
                const [existingEmail] = await db.promise().query(
                    'SELECT id FROM users WHERE email = ? AND id != ?',
                    [email, userId]
                );
                
                if (existingEmail.length > 0) {
                    return res.status(400).json({
                        success: false,
                        message: 'El email ya est√° en uso por otro usuario'
                    });
                }
            }
            
            // Verificar si el username ya existe (si se est√° cambiando)
            if (username && username !== users[0].username) {
                const [existingUsername] = await db.promise().query(
                    'SELECT id FROM users WHERE username = ? AND id != ?',
                    [username, userId]
                );
                
                if (existingUsername.length > 0) {
                    return res.status(400).json({
                        success: false,
                        message: 'El nombre de usuario ya est√° en uso'
                    });
                }
            }
            
            // Construir query de actualizaci√≥n din√°mica
            const updates = [];
            const values = [];
            
            if (username !== undefined) {
                updates.push('username = ?');
                values.push(username);
            }
            
            if (email !== undefined) {
                updates.push('email = ?');
                values.push(email);
            }
            
            if (nombreCompleto !== undefined) {
                updates.push('nombre_completo = ?');
                values.push(nombreCompleto);
            }
            
            if (telefono !== undefined) {
                updates.push('telefono = ?');
                values.push(telefono);
            }
            
            if (institucion !== undefined) {
                updates.push('institucion = ?');
                values.push(institucion);
            }
            
            if (avatar !== undefined) {
                updates.push('avatar = ?');
                values.push(avatar);
            }
            
            // Si no hay nada para actualizar
            if (updates.length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No hay datos para actualizar'
                });
            }
            
            // Agregar ID al final
            values.push(userId);
            
            // Ejecutar actualizaci√≥n
            const query = `UPDATE users SET ${updates.join(', ')}, updated_at = NOW() WHERE id = ?`;
            await db.promise().query(query, values);
            
            // Obtener usuario actualizado
            const [updatedUser] = await db.promise().query(
                'SELECT * FROM users WHERE id = ?',
                [userId]
            );
            
            console.log('‚úÖ Perfil actualizado exitosamente');
            
            res.json({
                success: true,
                message: 'Perfil actualizado exitosamente',
                user: {
                    id: updatedUser[0].id,
                    username: updatedUser[0].username,
                    email: updatedUser[0].email,
                    role: updatedUser[0].role,
                    nombreCompleto: updatedUser[0].nombre_completo || '',
                    telefono: updatedUser[0].telefono || '',
                    institucion: updatedUser[0].institucion || '',
                    avatar: updatedUser[0].avatar || null,
                    numeroTrabajador: updatedUser[0].numero_trabajador || null
                }
            });
            
        } catch (error) {
            console.error('‚ùå Error actualizando perfil:', error);
            res.status(500).json({
                success: false,
                message: 'Error en el servidor',
                error: process.env.NODE_ENV === 'development' ? error.message : undefined
            });
        }
    }

    // ‚úÖ CAMBIAR CONTRASE√ëA
    static async changePassword(req, res) {
        try {
            const userId = req.user.userId;
            const { currentPassword, newPassword } = req.body;
            
            console.log('üîë Cambiando contrase√±a para usuario ID:', userId);
            
            // Validar campos
            if (!currentPassword || !newPassword) {
                return res.status(400).json({
                    success: false,
                    message: 'La contrase√±a actual y la nueva contrase√±a son requeridas'
                });
            }
            
            // Obtener usuario
            const [users] = await db.promise().query(
                'SELECT password FROM users WHERE id = ?',
                [userId]
            );
            
            if (users.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            const user = users[0];
            
            // Verificar contrase√±a actual
            let isPasswordValid = false;
            
            try {
                // Intentar con bcrypt
                isPasswordValid = await bcrypt.compare(currentPassword, user.password);
                
                // Si falla bcrypt pero coincide directamente (para migraci√≥n)
                if (!isPasswordValid && currentPassword === user.password) {
                    console.log('‚ö†Ô∏è Usando contrase√±a sin hash para verificaci√≥n (migraci√≥n)');
                    isPasswordValid = true;
                }
            } catch (bcryptError) {
                console.error('‚ùå Error en bcrypt compare:', bcryptError);
                // Si hay error en bcrypt, intentar comparaci√≥n directa
                isPasswordValid = (currentPassword === user.password);
            }
            
            if (!isPasswordValid) {
                return res.status(401).json({
                    success: false,
                    message: 'La contrase√±a actual es incorrecta'
                });
            }
            
            // Validar nueva contrase√±a (m√≠nimo 6 caracteres)
            if (newPassword.length < 6) {
                return res.status(400).json({
                    success: false,
                    message: 'La nueva contrase√±a debe tener al menos 6 caracteres'
                });
            }
            
            // Hash de nueva contrase√±a
            const hashedPassword = await bcrypt.hash(newPassword, 10);
            
            // Actualizar contrase√±a
            await db.promise().query(
                'UPDATE users SET password = ?, updated_at = NOW() WHERE id = ?',
                [hashedPassword, userId]
            );
            
            console.log('‚úÖ Contrase√±a cambiada exitosamente');
            
            res.json({
                success: true,
                message: 'Contrase√±a cambiada exitosamente'
            });
            
        } catch (error) {
            console.error('‚ùå Error cambiando contrase√±a:', error);
            res.status(500).json({
                success: false,
                message: 'Error en el servidor',
                error: process.env.NODE_ENV === 'development' ? error.message : undefined
            });
        }
    }

    // ‚úÖ ACTUALIZAR SOLO AVATAR
    static async updateAvatar(req, res) {
        try {
            const userId = req.user.userId;
            const { avatar } = req.body;
            
            console.log('üñºÔ∏è Actualizando avatar para usuario ID:', userId);
            
            if (!avatar) {
                return res.status(400).json({
                    success: false,
                    message: 'Se requiere una imagen de avatar'
                });
            }
            
            // Verificar si el usuario existe
            const [users] = await db.promise().query(
                'SELECT id FROM users WHERE id = ?',
                [userId]
            );
            
            if (users.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            // Actualizar avatar
            await db.promise().query(
                'UPDATE users SET avatar = ?, updated_at = NOW() WHERE id = ?',
                [avatar, userId]
            );
            
            // Obtener usuario actualizado
            const [updatedUser] = await db.promise().query(
                'SELECT * FROM users WHERE id = ?',
                [userId]
            );
            
            console.log('‚úÖ Avatar actualizado exitosamente');
            
            res.json({
                success: true,
                message: 'Avatar actualizado exitosamente',
                user: {
                    id: updatedUser[0].id,
                    username: updatedUser[0].username,
                    email: updatedUser[0].email,
                    role: updatedUser[0].role,
                    nombreCompleto: updatedUser[0].nombre_completo || '',
                    telefono: updatedUser[0].telefono || '',
                    institucion: updatedUser[0].institucion || '',
                    avatar: updatedUser[0].avatar || null
                }
            });
            
        } catch (error) {
            console.error('‚ùå Error actualizando avatar:', error);
            res.status(500).json({
                success: false,
                message: 'Error en el servidor',
                error: process.env.NODE_ENV === 'development' ? error.message : undefined
            });
        }
    }

    // ‚úÖ ACTUALIZAR PERFIL COMPLETO (DATOS + PASSWORD SI SE PROVEE)
    static async updateFullProfile(req, res) {
        try {
            const userId = req.user.userId;
            const { 
                username, 
                email, 
                nombreCompleto, 
                telefono, 
                institucion,
                avatar,
                currentPassword,
                newPassword 
            } = req.body;
            
            console.log('üìù Actualizando perfil completo para usuario ID:', userId);
              if (avatar && avatar.length > 16000000) { // ~16MB para MEDIUMTEXT
            return res.status(400).json({
                success: false,
                message: 'La imagen de avatar es demasiado grande. M√°ximo 16MB permitido.'
            });
        }
            
            // Primero verificar cambio de contrase√±a si se proporciona
            if (currentPassword && newPassword) {
                console.log('üîë Intentando cambiar contrase√±a...');
                
                // Obtener usuario actual
                const [users] = await db.promise().query(
                    'SELECT password FROM users WHERE id = ?',
                    [userId]
                );
                
                if (users.length === 0) {
                    return res.status(404).json({
                        success: false,
                        message: 'Usuario no encontrado'
                    });
                }
                
                const user = users[0];
                
                // Verificar contrase√±a actual
                let isPasswordValid = false;
                
                try {
                    // Intentar con bcrypt
                    isPasswordValid = await bcrypt.compare(currentPassword, user.password);
                    
                    // Si falla bcrypt pero coincide directamente
                    if (!isPasswordValid && currentPassword === user.password) {
                        isPasswordValid = true;
                    }
                } catch (bcryptError) {
                    console.error('‚ùå Error en bcrypt compare:', bcryptError);
                    isPasswordValid = (currentPassword === user.password);
                }
                
                if (!isPasswordValid) {
                    return res.status(401).json({
                        success: false,
                        message: 'La contrase√±a actual es incorrecta'
                    });
                }
                
                // Validar nueva contrase√±a
                if (newPassword.length < 6) {
                    return res.status(400).json({
                        success: false,
                        message: 'La nueva contrase√±a debe tener al menos 6 caracteres'
                    });
                }
                
                // Hash de nueva contrase√±a
                const hashedPassword = await bcrypt.hash(newPassword, 10);
                
                // Actualizar contrase√±a
                await db.promise().query(
                    'UPDATE users SET password = ? WHERE id = ?',
                    [hashedPassword, userId]
                );
                
                console.log('‚úÖ Contrase√±a cambiada exitosamente');
            }
            
            // Ahora actualizar datos del perfil
            const updates = [];
            const values = [];
            
            if (username !== undefined) {
                updates.push('username = ?');
                values.push(username);
            }
            
            if (email !== undefined) {
                // Verificar si el email ya existe
                if (email) {
                    const [existingEmail] = await db.promise().query(
                        'SELECT id FROM users WHERE email = ? AND id != ?',
                        [email, userId]
                    );
                    
                    if (existingEmail.length > 0) {
                        return res.status(400).json({
                            success: false,
                            message: 'El email ya est√° en uso por otro usuario'
                        });
                    }
                    updates.push('email = ?');
                    values.push(email);
                }
            }
            
            if (nombreCompleto !== undefined) {
                updates.push('nombre_completo = ?');
                values.push(nombreCompleto);
            }
            
            if (telefono !== undefined) {
                updates.push('telefono = ?');
                values.push(telefono);
            }
            
            if (institucion !== undefined) {
                updates.push('institucion = ?');
                values.push(institucion);
            }
            
            if (avatar !== undefined) {
                updates.push('avatar = ?');
                values.push(avatar);
            }
            
            // Si hay algo para actualizar
            if (updates.length > 0) {
                values.push(userId);
                
                const query = `UPDATE users SET ${updates.join(', ')}, updated_at = NOW() WHERE id = ?`;
                await db.promise().query(query, values);
                console.log('‚úÖ Datos de perfil actualizados');
            }
            
            // Obtener usuario actualizado
            const [updatedUser] = await db.promise().query(
                'SELECT * FROM users WHERE id = ?',
                [userId]
            );
            
            console.log('‚úÖ Perfil completo actualizado exitosamente');
            
            res.json({
                success: true,
                message: 'Perfil actualizado exitosamente',
                user: {
                    id: updatedUser[0].id,
                    username: updatedUser[0].username,
                    email: updatedUser[0].email,
                    role: updatedUser[0].role,
                    nombreCompleto: updatedUser[0].nombre_completo || '',
                    telefono: updatedUser[0].telefono || '',
                    institucion: updatedUser[0].institucion || '',
                    avatar: updatedUser[0].avatar || null
                }
            });
            
        } catch (error) {
            console.error('‚ùå Error actualizando perfil completo:', error);
            res.status(500).json({
                success: false,
                message: 'Error en el servidor',
                error: process.env.NODE_ENV === 'development' ? error.message : undefined
            });
        }
    }
}

// ‚úÖ Aseg√∫rate de exportar la clase correctamente
module.exports = AuthController;
const db = require('../config/database');

class CareerController {
    // ‚úÖ OBTENER CARRERAS POR USUARIO
    static async getByUser(req, res) {
        try {
            const userId = req.user.userId;
            
            console.log('üéì Obteniendo carreras para usuario ID:', userId);
            
            const [careers] = await db.promise().query(
                'SELECT * FROM careers WHERE user_id = ? ORDER BY created_at DESC',
                [userId]
            );
            
            console.log(`üìä Encontradas ${careers.length} carreras para usuario ${userId}`);
            
            res.json({
                success: true,
                data: careers,
                count: careers.length
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo carreras:', error);
            res.status(500).json({
                success: false,
                message: 'Error obteniendo carreras: ' + error.message
            });
        }
    }

    // ‚úÖ OBTENER TODAS LAS CARRERAS (solo admin)
    static async getAll(req, res) {
        try {
            const [careers] = await db.promise().query(`
                SELECT c.*, u.username as propietario
                FROM careers c
                LEFT JOIN users u ON c.user_id = u.id
                ORDER BY c.created_at DESC
            `);
            
            res.json({
                success: true,
                data: careers,
                count: careers.length
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo todas las carreras:', error);
            res.status(500).json({
                success: false,
                message: 'Error obteniendo carreras: ' + error.message
            });
        }
    }

    // ‚úÖ CREAR CARRERA CON M√âTRICAS Y LOGO
    static async create(req, res) {
        try {
            const userId = req.user.userId;
            const {
                nombre,
                numeroCarrera,
                cantidadAlumnos,
                duracionSemestres,
                modalidad,
                turno,
                descripcion,
                activa,
                poblacionEsperada,
                poblacionReal,
                logo
            } = req.body;
            
            console.log('üìù Creando carrera para usuario:', userId);
            console.log('üìä Datos recibidos:', req.body);
            
            // Validar campos requeridos
            if (!nombre || !numeroCarrera) {
                return res.status(400).json({
                    success: false,
                    message: 'Nombre y n√∫mero de carrera son requeridos'
                });
            }
            
            // Verificar si ya existe el n√∫mero de carrera
            const [existing] = await db.promise().query(
                'SELECT id FROM careers WHERE numero_carrera = ?',
                [numeroCarrera]
            );
            
            if (existing.length > 0) {
                return res.status(400).json({
                    success: false,
                    message: 'El n√∫mero de carrera ya existe'
                });
            }
            
            // Insertar carrera con TODOS los campos
            const [result] = await db.promise().query(
                `INSERT INTO careers 
                (user_id, nombre, numero_carrera, cantidad_alumnos, 
                 duracion_semestres, modalidad, turno, fecha_registro, 
                 descripcion, activa, poblacion_esperada, poblacion_real, logo) 
                VALUES (?, ?, ?, ?, ?, ?, ?, CURDATE(), ?, ?, ?, ?, ?)`,
                [
                    userId, 
                    nombre, 
                    numeroCarrera, 
                    cantidadAlumnos || 0, 
                    duracionSemestres || 8,
                    modalidad || 'Escolarizada',
                    turno || 'Matutino',
                    descripcion || '',
                    activa !== undefined ? (activa ? 1 : 0) : 1,
                    poblacionEsperada || 100,
                    poblacionReal || 50,
                    logo || null
                ]
            );
            
            // Obtener carrera creada
            const [career] = await db.promise().query(
                'SELECT * FROM careers WHERE id = ?',
                [result.insertId]
            );
            
            console.log('‚úÖ Carrera creada exitosamente');
            
            res.status(201).json({
                success: true,
                message: 'Carrera creada exitosamente',
                career: career[0]
            });
            
        } catch (error) {
            console.error('‚ùå Error creando carrera:', error);
            res.status(500).json({
                success: false,
                message: 'Error creando carrera: ' + error.message
            });
        }
    }

    // ‚úÖ OBTENER CARRERA POR ID
    static async getById(req, res) {
        try {
            const { id } = req.params;
            
            const [careers] = await db.promise().query(
                'SELECT * FROM careers WHERE id = ?',
                [id]
            );
            
            if (careers.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Carrera no encontrada'
                });
            }
            
            res.json({
                success: true,
                career: careers[0]
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo carrera:', error);
            res.status(500).json({
                success: false,
                message: 'Error obteniendo carrera: ' + error.message
            });
        }
    }

    // ‚úÖ ACTUALIZAR CARRERA COMPLETA
    static async update(req, res) {
        try {
            const { id } = req.params;
            const userId = req.user.userId;
            const updateData = req.body;
            
            console.log(`‚úèÔ∏è Actualizando carrera ${id} para usuario ${userId}`);
            console.log('üìä Datos para actualizar:', updateData);
            
            // Verificar que la carrera existe y pertenece al usuario
            const [career] = await db.promise().query(
                'SELECT * FROM careers WHERE id = ? AND user_id = ?',
                [id, userId]
            );
            
            if (career.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Carrera no encontrada o no tienes permisos'
                });
            }
            
            // Construir query de actualizaci√≥n
            const fields = [];
            const values = [];
            
            // Mapeo de campos frontend a backend
            const fieldMappings = {
                nombre: 'nombre',
                numeroCarrera: 'numero_carrera',
                cantidadAlumnos: 'cantidad_alumnos',
                duracionSemestres: 'duracion_semestres',
                modalidad: 'modalidad',
                turno: 'turno',
                descripcion: 'descripcion',
                activa: 'activa',
                poblacionEsperada: 'poblacion_esperada',
                poblacionReal: 'poblacion_real',
                logo: 'logo'
            };
            
            for (const [frontendField, backendField] of Object.entries(fieldMappings)) {
                if (updateData[frontendField] !== undefined) {
                    fields.push(`${backendField} = ?`);
                    
                    // Manejar valores booleanos para activa
                    if (frontendField === 'activa') {
                        values.push(updateData[frontendField] ? 1 : 0);
                    } else {
                        values.push(updateData[frontendField]);
                    }
                }
            }
            
            if (fields.length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No hay datos para actualizar'
                });
            }
            
            values.push(id, userId);
            
            const query = `UPDATE careers SET ${fields.join(', ')}, updated_at = NOW() WHERE id = ? AND user_id = ?`;
            
            await db.promise().query(query, values);
            
            console.log('‚úÖ Carrera actualizada exitosamente');
            
            res.json({
                success: true,
                message: 'Carrera actualizada exitosamente'
            });
            
        } catch (error) {
            console.error('‚ùå Error actualizando carrera:', error);
            res.status(500).json({
                success: false,
                message: 'Error actualizando carrera: ' + error.message
            });
        }
    }

    // ‚úÖ ACTUALIZAR SOLO M√âTRICAS DE CARRERA
    static async updateMetrics(req, res) {
        try {
            const { id } = req.params;
            const userId = req.user.userId;
            const { poblacionEsperada, poblacionReal } = req.body;
            
            console.log(`üìà Actualizando m√©tricas para carrera ${id}, usuario: ${userId}`);
            console.log('üìä Datos recibidos:', { poblacionEsperada, poblacionReal });
            
            // Verificar que la carrera existe y pertenece al usuario
            const [career] = await db.promise().query(
                'SELECT id FROM careers WHERE id = ? AND user_id = ?',
                [id, userId]
            );
            
            if (career.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Carrera no encontrada o no tienes permisos'
                });
            }
            
            // Validar m√©tricas
            if (poblacionEsperada === undefined || poblacionReal === undefined) {
                return res.status(400).json({
                    success: false,
                    message: 'Ambas m√©tricas (poblacionEsperada y poblacionReal) son requeridas'
                });
            }
            
            // Actualizar m√©tricas
            await db.promise().query(
                'UPDATE careers SET poblacion_esperada = ?, poblacion_real = ?, updated_at = NOW() WHERE id = ?',
                [poblacionEsperada, poblacionReal, id]
            );
            
            console.log('‚úÖ M√©tricas actualizadas exitosamente');
            
            res.json({
                success: true,
                message: 'M√©tricas actualizadas exitosamente'
            });
            
        } catch (error) {
            console.error('‚ùå Error actualizando m√©tricas:', error);
            res.status(500).json({
                success: false,
                message: 'Error actualizando m√©tricas: ' + error.message
            });
        }
    }

    // ‚úÖ ELIMINAR CARRERA
    static async delete(req, res) {
        try {
            const { id } = req.params;
            const userId = req.user.userId;
            
            console.log(`üóëÔ∏è Eliminando carrera ${id} para usuario ${userId}`);
            
            // Verificar que la carrera existe y pertenece al usuario
            const [career] = await db.promise().query(
                'SELECT id FROM careers WHERE id = ? AND user_id = ?',
                [id, userId]
            );
            
            if (career.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Carrera no encontrada o no tienes permisos'
                });
            }
            
            // Eliminar relaciones primero
            await db.promise().query(
                'DELETE FROM institution_careers WHERE career_id = ?',
                [id]
            );
            
            // Eliminar carrera
            await db.promise().query(
                'DELETE FROM careers WHERE id = ?',
                [id]
            );
            
            console.log('‚úÖ Carrera eliminada exitosamente');
            
            res.json({
                success: true,
                message: 'Carrera eliminada exitosamente'
            });
            
        } catch (error) {
            console.error('‚ùå Error eliminando carrera:', error);
            res.status(500).json({
                success: false,
                message: 'Error eliminando carrera: ' + error.message
            });
        }
    }

    // ‚úÖ OBTENER CARRERAS DISPONIBLES (sin autenticaci√≥n)
    static async getAvailable(req, res) {
        try {
            const [careers] = await db.promise().query(
                'SELECT * FROM careers WHERE activa = 1 ORDER BY nombre'
            );
            
            res.json({
                success: true,
                data: careers,
                count: careers.length
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo carreras disponibles:', error);
            res.status(500).json({
                success: false,
                message: 'Error obteniendo carreras disponibles: ' + error.message
            });
        }
    }

    // ‚úÖ OBTENER ESTAD√çSTICAS DE CARRERAS
    static async getStats(req, res) {
        try {
            const [stats] = await db.promise().query(`
                SELECT 
                    COUNT(*) as total_careers,
                    SUM(CASE WHEN activa = 1 THEN 1 ELSE 0 END) as active_careers,
                    SUM(CASE WHEN activa = 0 THEN 1 ELSE 0 END) as inactive_careers,
                    SUM(poblacion_esperada) as total_poblacion_esperada,
                    SUM(poblacion_real) as total_poblacion_real,
                    AVG(poblacion_esperada) as promedio_esperada,
                    AVG(poblacion_real) as promedio_real,
                    modalidad,
                    COUNT(*) as count_by_modalidad
                FROM careers
                GROUP BY modalidad
            `);
            
            const [turnoStats] = await db.promise().query(`
                SELECT turno, COUNT(*) as count_by_turno
                FROM careers
                GROUP BY turno
            `);
            
            const totalEsperada = stats.reduce((sum, s) => sum + (s.total_poblacion_esperada || 0), 0);
            const totalReal = stats.reduce((sum, s) => sum + (s.total_poblacion_real || 0), 0);
            const porcentajeCumplimiento = totalEsperada > 0 ? (totalReal / totalEsperada) * 100 : 0;
            
            res.json({
                success: true,
                statistics: {
                    totalCareers: stats.reduce((sum, s) => sum + s.total_careers, 0) || 0,
                    activeCareers: stats.reduce((sum, s) => sum + s.active_careers, 0) || 0,
                    inactiveCareers: stats.reduce((sum, s) => sum + s.inactive_careers, 0) || 0,
                    totalPoblacionEsperada: totalEsperada,
                    totalPoblacionReal: totalReal,
                    promedioPoblacionEsperada: stats.reduce((sum, s) => sum + (s.promedio_esperada || 0), 0) / stats.length || 0,
                    promedioPoblacionReal: stats.reduce((sum, s) => sum + (s.promedio_real || 0), 0) / stats.length || 0,
                    porcentajeCumplimiento: porcentajeCumplimiento.toFixed(2),
                    careersByModalidad: stats.reduce((obj, s) => {
                        obj[s.modalidad] = s.count_by_modalidad;
                        return obj;
                    }, {}),
                    careersByTurno: turnoStats.reduce((obj, s) => {
                        obj[s.turno] = s.count_by_turno;
                        return obj;
                    }, {})
                }
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo estad√≠sticas:', error);
            res.status(500).json({
                success: false,
                message: 'Error obteniendo estad√≠sticas: ' + error.message
            });
        }
    }
}

module.exports = CareerController;
const db = require('../config/database');

class InstitutionController {
    // ‚úÖ OBTENER INSTITUCIONES POR USUARIO
    static async getByUser(req, res) {
        try {
            const userId = req.user.userId;
            
            console.log('üìã Obteniendo instituciones para usuario ID:', userId);
            
            const [institutions] = await db.promise().query(
                'SELECT * FROM institutions WHERE user_id = ? ORDER BY created_at DESC',
                [userId]
            );
            
            console.log(`üìä Encontradas ${institutions.length} instituciones para usuario ${userId}`);
            
            // Tambi√©n obtener las carreras asociadas a cada instituci√≥n
            const institutionsWithCareers = await Promise.all(
                institutions.map(async (institution) => {
                    const [careers] = await db.promise().query(
                        `SELECT c.* FROM careers c
                         JOIN institution_careers ic ON c.id = ic.career_id
                         WHERE ic.institution_id = ?`,
                        [institution.id]
                    );
                    
                    return {
                        ...institution,
                        carreras: careers.map(c => ({
                            id: c.id,
                            nombre: c.nombre,
                            numeroCarrera: c.numero_carrera
                        }))
                    };
                })
            );
            
            res.json({
                success: true,
                data: institutionsWithCareers,
                count: institutions.length
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo instituciones:', error);
            res.status(500).json({
                success: false,
                message: 'Error obteniendo instituciones: ' + error.message
            });
        }
    }

    // ‚úÖ OBTENER INSTITUCI√ìN POR ID
    static async getById(req, res) {
        try {
            const { id } = req.params;
            const userId = req.user.userId;
            
            console.log('üîç Obteniendo instituci√≥n ID:', id, 'para usuario:', userId);
            
            const [institutions] = await db.promise().query(
                'SELECT * FROM institutions WHERE id = ? AND user_id = ?',
                [id, userId]
            );
            
            if (institutions.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Instituci√≥n no encontrada o no tienes permisos'
                });
            }
            
            const institution = institutions[0];
            
            // Obtener carreras asociadas
            const [careers] = await db.promise().query(
                `SELECT c.* FROM careers c
                 JOIN institution_careers ic ON c.id = ic.career_id
                 WHERE ic.institution_id = ?`,
                [id]
            );
            
            const institutionWithCareers = {
                ...institution,
                carreras: careers.map(c => ({
                    id: c.id,
                    nombre: c.nombre,
                    numeroCarrera: c.numero_carrera
                }))
            };
            
            res.json({
                success: true,
                data: institutionWithCareers
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo instituci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error obteniendo instituci√≥n: ' + error.message
            });
        }
    }

    // ‚úÖ CREAR INSTITUCI√ìN
    static async create(req, res) {
        try {
            const userId = req.user.userId;
            const {
                nombre,
                claveCCT,
                telefono,
                extension,
                correo,
                nombreRepresentante,
                puestoRepresentante,
                direccion,
                logo,
                estado,
                carreras
            } = req.body;
            
            console.log('üè´ Creando instituci√≥n para usuario:', userId);
            console.log('üìã Datos recibidos:', { 
                nombre, 
                claveCCT, 
                carrerasCount: carreras?.length || 0 
            });
            
            // Validar campos requeridos
            if (!nombre || !claveCCT) {
                return res.status(400).json({
                    success: false,
                    message: 'Nombre y clave CCT son requeridos'
                });
            }
            
            // Verificar si la clave CCT ya existe
            const [existing] = await db.promise().query(
                'SELECT id FROM institutions WHERE clave_cct = ?',
                [claveCCT]
            );
            
            if (existing.length > 0) {
                return res.status(400).json({
                    success: false,
                    message: 'La clave CCT ya existe'
                });
            }
            
            // Insertar instituci√≥n
            const [result] = await db.promise().query(
                `INSERT INTO institutions 
                (user_id, nombre, clave_cct, telefono, extension, correo, 
                 nombre_representante, puesto_representante, direccion, logo, estado) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    userId, nombre, claveCCT, telefono || null, extension || null,
                    correo || null, nombreRepresentante || null, puestoRepresentante || null,
                    direccion || null, logo || null, estado || 'active'
                ]
            );
            
            const institutionId = result.insertId;
            console.log('‚úÖ Instituci√≥n creada con ID:', institutionId);
            
            // Asociar carreras si se proporcionaron
            if (carreras && carreras.length > 0) {
                console.log('üéì Asociando', carreras.length, 'carreras a la instituci√≥n');
                
                for (const careerId of carreras) {
                    try {
                        await db.promise().query(
                            'INSERT INTO institution_careers (institution_id, career_id) VALUES (?, ?)',
                            [institutionId, careerId]
                        );
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è No se pudo asociar carrera ${careerId}:`, error.message);
                    }
                }
            }
            
            // Obtener instituci√≥n creada
            const [newInstitution] = await db.promise().query(
                'SELECT * FROM institutions WHERE id = ?',
                [institutionId]
            );
            
            res.status(201).json({
                success: true,
                message: 'Instituci√≥n creada exitosamente',
                data: newInstitution[0]
            });
            
        } catch (error) {
            console.error('‚ùå Error creando instituci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error creando instituci√≥n: ' + error.message
            });
        }
    }

    // ‚úÖ ACTUALIZAR INSTITUCI√ìN - VERSI√ìN CORREGIDA
    static async update(req, res) {
        try {
            const { id } = req.params;
            const userId = req.user.userId;
            const updateData = req.body;
            
            console.log(`‚úèÔ∏è Actualizando instituci√≥n ${id} para usuario ${userId}`);
            console.log('üìä Datos para actualizar:', updateData);
            
            // Verificar que la instituci√≥n existe y pertenece al usuario
            const [institution] = await db.promise().query(
                'SELECT * FROM institutions WHERE id = ? AND user_id = ?',
                [id, userId]
            );
            
            if (institution.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Instituci√≥n no encontrada o no tienes permisos'
                });
            }
            
            // Construir query de actualizaci√≥n
            const fields = [];
            const values = [];
            
            // A√±adir todos los campos que puedan actualizarse
            const fieldMappings = {
                nombre: 'nombre',
                claveCCT: 'clave_cct',
                telefono: 'telefono',
                extension: 'extension',
                correo: 'correo',
                nombreRepresentante: 'nombre_representante',
                puestoRepresentante: 'puesto_representante',
                direccion: 'direccion',
                logo: 'logo',
                estado: 'estado'
            };
            
            for (const [frontendField, backendField] of Object.entries(fieldMappings)) {
                if (updateData[frontendField] !== undefined) {
                    fields.push(`${backendField} = ?`);
                    values.push(updateData[frontendField]);
                }
            }
            
            if (fields.length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No hay datos para actualizar'
                });
            }
            
            values.push(id, userId);
            
            const query = `UPDATE institutions SET ${fields.join(', ')}, updated_at = NOW() WHERE id = ? AND user_id = ?`;
            
            await db.promise().query(query, values);
            
            // Manejar actualizaci√≥n de carreras si se proporcionan
            if (updateData.carreras !== undefined) {
                console.log('üîÑ Actualizando carreras asociadas:', updateData.carreras);
                
                // Eliminar relaciones existentes
                await db.promise().query(
                    'DELETE FROM institution_careers WHERE institution_id = ?',
                    [id]
                );
                
                // Agregar nuevas relaciones
                if (updateData.carreras && updateData.carreras.length > 0) {
                    const placeholders = updateData.carreras.map(() => '(?, ?)').join(', ');
                    const insertValues = updateData.carreras.flatMap(careerId => [id, careerId]);
                    
                    await db.promise().query(
                        `INSERT INTO institution_careers (institution_id, career_id) VALUES ${placeholders}`,
                        insertValues
                    );
                }
            }
            
            console.log('‚úÖ Instituci√≥n actualizada exitosamente');
            
            res.json({
                success: true,
                message: 'Instituci√≥n actualizada exitosamente'
            });
            
        } catch (error) {
            console.error('‚ùå Error actualizando instituci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error actualizando instituci√≥n: ' + error.message
            });
        }
    }

    // ‚úÖ ELIMINAR INSTITUCI√ìN
    static async delete(req, res) {
        try {
            const { id } = req.params;
            const userId = req.user.userId;
            
            console.log(`üóëÔ∏è Eliminando instituci√≥n ${id} para usuario ${userId}`);
            
            // Verificar que la instituci√≥n existe y pertenece al usuario
            const [institution] = await db.promise().query(
                'SELECT id FROM institutions WHERE id = ? AND user_id = ?',
                [id, userId]
            );
            
            if (institution.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'Instituci√≥n no encontrada o no tienes permisos'
                });
            }
            
            // Eliminar relaciones con carreras primero
            await db.promise().query(
                'DELETE FROM institution_careers WHERE institution_id = ?',
                [id]
            );
            
            // Eliminar instituci√≥n
            await db.promise().query(
                'DELETE FROM institutions WHERE id = ?',
                [id]
            );
            
            console.log('‚úÖ Instituci√≥n eliminada exitosamente');
            
            res.json({
                success: true,
                message: 'Instituci√≥n eliminada exitosamente'
            });
            
        } catch (error) {
            console.error('‚ùå Error eliminando instituci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error eliminando instituci√≥n: ' + error.message
            });
        }
    }

    // ‚úÖ OBTENER TODAS LAS INSTITUCIONES (solo admin)
    static async getAll(req, res) {
        try {
            const [institutions] = await db.promise().query(`
                SELECT i.*, u.username as propietario
                FROM institutions i
                LEFT JOIN users u ON i.user_id = u.id
                ORDER BY i.created_at DESC
            `);
            
            res.json({
                success: true,
                data: institutions,
                count: institutions.length
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo todas las instituciones:', error);
            res.status(500).json({
                success: false,
                message: 'Error obteniendo instituciones: ' + error.message
            });
        }
    }

    // ‚úÖ M√âTODOS ADICIONALES PARA EL DASHBOARD

    // Obtener estad√≠sticas del sistema
    static async getStatistics(req, res) {
        try {
            const [userStats] = await db.promise().query(`
                SELECT 
                    COUNT(*) as total_users,
                    SUM(CASE WHEN role = 'admin' THEN 1 ELSE 0 END) as admin_users,
                    SUM(CASE WHEN role = 'user' THEN 1 ELSE 0 END) as normal_users
                FROM users
            `);
            
            const [institutionStats] = await db.promise().query(`
                SELECT 
                    COUNT(*) as total_institutions,
                    SUM(CASE WHEN estado = 'active' THEN 1 ELSE 0 END) as active_institutions
                FROM institutions
            `);
            
            const [careerStats] = await db.promise().query(`
                SELECT 
                    COUNT(*) as total_careers,
                    SUM(CASE WHEN activa = 1 THEN 1 ELSE 0 END) as active_careers,
                    SUM(poblacion_esperada) as total_poblacion_esperada,
                    SUM(poblacion_real) as total_poblacion_real
                FROM careers
            `);
            
            res.json({
                success: true,
                statistics: {
                    users: userStats[0],
                    institutions: institutionStats[0],
                    careers: careerStats[0]
                }
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo estad√≠sticas:', error);
            res.status(500).json({
                success: false,
                message: 'Error obteniendo estad√≠sticas: ' + error.message
            });
        }
    }

    // Obtener tecnol√≥gicos pre-registrados
    static async getPreRegisteredInstitutions(req, res) {
        try {
            // Aqu√≠ puedes cargar datos de ejemplo o de un archivo JSON
            const preRegisteredTecs = [
                {
                    nombre: 'Tecnol√≥gico Nacional de M√©xico - Campus Centro',
                    claveCCT: 'CCT001',
                    telefono: '555-1000',
                    correo: 'contacto@tecnm.mx',
                    nombreRepresentante: 'Dr. Juan P√©rez',
                    puestoRepresentante: 'Director General',
                    direccion: 'Av. Universidad 1000, Ciudad de M√©xico',
                    carreras: ['Ingenier√≠a en Sistemas Computacionales', 'Ingenier√≠a Industrial']
                },
                {
                    nombre: 'Tecnol√≥gico de Estudios Superiores del Oriente',
                    claveCCT: 'CCT002',
                    telefono: '555-2000',
                    correo: 'info@teso.edu.mx',
                    nombreRepresentante: 'Ing. Mar√≠a Garc√≠a',
                    puestoRepresentante: 'Directora',
                    direccion: 'Carretera Federal, Estado de M√©xico',
                    carreras: ['Licenciatura en Administraci√≥n', 'Ingenier√≠a en Mecatr√≥nica']
                },
                {
                    nombre: 'Tecnol√≥gico de Monterrey - Campus Ciudad de M√©xico',
                    claveCCT: 'CCT003',
                    telefono: '555-3000',
                    correo: 'admisiones@tec.mx',
                    nombreRepresentante: 'Lic. Roberto S√°nchez',
                    puestoRepresentante: 'Director de Admisiones',
                    direccion: 'Calzada del Valle 400, San Pedro Garza Garc√≠a',
                    carreras: ['Ingenier√≠a en Sistemas Digitales', 'Ingenier√≠a en Biotecnolog√≠a']
                }
            ];
            
            res.json({
                success: true,
                tecs: preRegisteredTecs,
                count: preRegisteredTecs.length
            });
            
        } catch (error) {
            console.error('‚ùå Error obteniendo tecnol√≥gicos pre-registrados:', error);
            res.status(500).json({
                success: false,
                message: 'Error obteniendo tecnol√≥gicos pre-registrados: ' + error.message
            });
        }
    }

    // Cargar tecnol√≥gicos pre-registrados para el usuario actual
    static async loadPreRegisteredInstitutions(req, res) {
        try {
            const userId = req.user.userId;
            
            console.log('‚ö° Cargando tecnol√≥gicos pre-registrados para usuario:', userId);
            
            // Verificar si el usuario ya tiene instituciones
            const [existingInstitutions] = await db.promise().query(
                'SELECT COUNT(*) as count FROM institutions WHERE user_id = ?',
                [userId]
            );
            
            if (existingInstitutions[0].count > 0 && req.user.role !== 'admin') {
                return res.status(400).json({
                    success: false,
                    message: 'Ya tienes instituciones registradas. Los usuarios normales solo pueden tener una instituci√≥n.'
                });
            }
            
            // Datos de ejemplo de tecnol√≥gicos pre-registrados
            const preRegisteredTecs = [
                {
                    nombre: 'Tecnol√≥gico Nacional de M√©xico - Campus Centro',
                    claveCCT: 'CCT' + Date.now(), // Generar CCT √∫nico
                    telefono: '555-1000',
                    correo: 'contacto@tecnm.mx',
                    nombreRepresentante: 'Dr. Juan P√©rez',
                    puestoRepresentante: 'Director General',
                    direccion: 'Av. Universidad 1000, Ciudad de M√©xico',
                    estado: 'active',
                    carreras: [1, 2] // IDs de carreras existentes
                }
            ];
            
            let addedCount = 0;
            
            // Insertar cada tecnol√≥gico
            for (const tec of preRegisteredTecs) {
                try {
                    // Insertar instituci√≥n
                    const [result] = await db.promise().query(
                        `INSERT INTO institutions 
                        (user_id, nombre, clave_cct, telefono, correo, 
                         nombre_representante, puesto_representante, direccion, estado) 
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                        [
                            userId, tec.nombre, tec.claveCCT, tec.telefono, tec.correo,
                            tec.nombreRepresentante, tec.puestoRepresentante, tec.direccion, tec.estado
                        ]
                    );
                    
                    const institutionId = result.insertId;
                    
                    // Asociar carreras
                    if (tec.carreras && tec.carreras.length > 0) {
                        for (const careerId of tec.carreras) {
                            await db.promise().query(
                                'INSERT INTO institution_careers (institution_id, career_id) VALUES (?, ?)',
                                [institutionId, careerId]
                            );
                        }
                    }
                    
                    addedCount++;
                    
                } catch (error) {
                    console.error('‚ùå Error insertando tecnol√≥gico:', error.message);
                }
            }
            
            console.log(`‚úÖ Cargados ${addedCount} tecnol√≥gicos pre-registrados`);
            
            res.json({
                success: true,
                message: `Se cargaron ${addedCount} tecnol√≥gicos pre-registrados exitosamente`,
                count: addedCount
            });
            
        } catch (error) {
            console.error('‚ùå Error cargando tecnol√≥gicos pre-registrados:', error);
            res.status(500).json({
                success: false,
                message: 'Error cargando tecnol√≥gicos pre-registrados: ' + error.message
            });
        }
    }

    // Exportar datos en diferentes formatos
    static async exportData(req, res) {
        try {
            const userId = req.user.userId;
            const format = req.query.format || 'json';
            
            console.log(`üì§ Exportando datos para usuario ${userId} en formato ${format}`);
            
            // Obtener instituciones del usuario
            const [institutions] = await db.promise().query(
                'SELECT * FROM institutions WHERE user_id = ?',
                [userId]
            );
            
            // Obtener carreras asociadas a cada instituci√≥n
            const institutionsWithCareers = await Promise.all(
                institutions.map(async (institution) => {
                    const [careers] = await db.promise().query(
                        `SELECT c.* FROM careers c
                         JOIN institution_careers ic ON c.id = ic.career_id
                         WHERE ic.institution_id = ?`,
                        [institution.id]
                    );
                    
                    return {
                        ...institution,
                        carreras: careers
                    };
                })
            );
            
            if (format === 'json') {
                res.json({
                    success: true,
                    data: institutionsWithCareers,
                    count: institutionsWithCareers.length,
                    exportDate: new Date().toISOString()
                });
            } else if (format === 'excel') {
                // Preparar datos para Excel
                const excelData = institutionsWithCareers.map(inst => ({
                    'ID': inst.id,
                    'Nombre': inst.nombre,
                    'Clave CCT': inst.clave_cct,
                    'Tel√©fono': inst.telefono,
                    'Correo': inst.correo,
                    'Representante': inst.nombre_representante,
                    'Puesto': inst.puesto_representante,
                    'Direcci√≥n': inst.direccion,
                    'Carreras': inst.carreras.map(c => c.nombre).join(', '),
                    'Estado': inst.estado,
                    'Fecha Registro': inst.created_at
                }));
                
                // En una implementaci√≥n real, usar√≠as una librer√≠a como xlsx
                // Para este ejemplo, devolvemos JSON
                res.json({
                    success: true,
                    message: 'Exportaci√≥n Excel en desarrollo',
                    data: excelData
                });
            } else {
                res.status(400).json({
                    success: false,
                    message: 'Formato no soportado. Use "json" o "excel".'
                });
            }
            
        } catch (error) {
            console.error('‚ùå Error exportando datos:', error);
            res.status(500).json({
                success: false,
                message: 'Error exportando datos: ' + error.message
            });
        }
    }
}

module.exports = InstitutionController;
const jwt = require('jsonwebtoken');

const authorize = (roles = []) => {
  // Si roles es un string, convertirlo a array
  if (typeof roles === 'string') {
    roles = [roles];
  }

  return (req, res, next) => {
    try {
      console.log('üîê Iniciando verificaci√≥n de autorizaci√≥n...');
      
      // Obtener token del header
      const authHeader = req.headers.authorization;
      
      if (!authHeader) {
        console.log('‚ùå No se encontr√≥ header de autorizaci√≥n');
        return res.status(401).json({
          success: false,
          message: 'Acceso no autorizado: Token no proporcionado'
        });
      }

      if (!authHeader.startsWith('Bearer ')) {
        console.log('‚ùå Formato de token incorrecto:', authHeader.substring(0, 20));
        return res.status(401).json({
          success: false,
          message: 'Formato de token inv√°lido. Use: Bearer <token>'
        });
      }

      const token = authHeader.split(' ')[1];
      
      if (!token) {
        console.log('‚ùå Token vac√≠o despu√©s de Bearer');
        return res.status(401).json({
          success: false,
          message: 'Token no proporcionado'
        });
      }

      console.log('üîë Verificando token...');
      
      // Verificar token
      const decoded = jwt.verify(
        token, 
        process.env.JWT_SECRET || 'clave_simple_tec_2024'
      );
      
      console.log('‚úÖ Token v√°lido para usuario:', {
        userId: decoded.userId,
        email: decoded.email,
        role: decoded.role
      });
      
      // Adjuntar usuario al request
      req.user = decoded;
      req.userId = decoded.userId; // Propiedad adicional para facilidad

      // Verificar rol si se especific√≥
      if (roles.length > 0) {
        console.log(`üîç Verificando rol. Requerido: ${roles}, Actual: ${decoded.role}`);
        
        if (!roles.includes(decoded.role)) {
          console.log('‚ùå Acceso denegado: Rol insuficiente');
          return res.status(403).json({
            success: false,
            message: 'Acceso denegado: No tienes los permisos necesarios',
            requiredRoles: roles,
            userRole: decoded.role
          });
        }
      }

      console.log('‚úÖ Autorizaci√≥n exitosa');
      next();
      
    } catch (error) {
      console.error('‚ùå Error en autenticaci√≥n:', {
        name: error.name,
        message: error.message,
        stack: error.stack
      });
      
      // Manejar diferentes tipos de errores de JWT
      if (error.name === 'JsonWebTokenError') {
        return res.status(401).json({
          success: false,
          message: 'Token inv√°lido o mal formado',
          error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
      }
      
      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({
          success: false,
          message: 'Token expirado. Por favor, inicie sesi√≥n nuevamente',
          expiredAt: error.expiredAt
        });
      }
      
      // Error de sintaxis (token mal formado)
      if (error.name === 'SyntaxError') {
        return res.status(401).json({
          success: false,
          message: 'Token mal formado'
        });
      }
      
      // Error interno del servidor
      console.error('‚ùå Error interno en middleware de autenticaci√≥n:', error);
      return res.status(500).json({
        success: false,
        message: 'Error interno en el servidor de autenticaci√≥n',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  };
};

// Middleware adicional para logging de peticiones autenticadas
const requestLogger = (req, res, next) => {
  console.log('üì• Nueva petici√≥n:', {
    method: req.method,
    url: req.url,
    ip: req.ip,
    timestamp: new Date().toISOString(),
    userAgent: req.headers['user-agent']
  });
  next();
};

// Middleware para parsear JSON con manejo de errores
const safeJsonParser = (err, req, res, next) => {
  if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
    console.error('‚ùå Error parseando JSON:', err.message);
    return res.status(400).json({
      success: false,
      message: 'JSON inv√°lido en el cuerpo de la petici√≥n',
      error: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
  next();
};

module.exports = { 
  authorize,
  requestLogger,
  safeJsonParser 
};
// career.model.js - ACTUALIZADO PARA TU ESTRUCTURA DE BD
const db = require('../config/database');

const Career = {
  // Crear carrera CON LOGO
  create: async (careerData) => {
    const {
      userId,
      nombre,
      numeroCarrera,
      cantidadAlumnos = 0,
      duracionSemestres = 8,
      modalidad = 'Escolarizada',
      turno = 'Matutino',
      descripcion = '',
      activa = true,
      poblacionEsperada = 0,
      poblacionReal = 0,
      logo = null
    } = careerData;

    return new Promise((resolve, reject) => {
      const query = `
        INSERT INTO careers 
        (user_id, nombre, numero_carrera, cantidad_alumnos, duracion_semestres,
         modalidad, turno, fecha_registro, descripcion, activa, 
         poblacion_esperada, poblacion_real, logo) 
        VALUES (?, ?, ?, ?, ?, ?, ?, CURDATE(), ?, ?, ?, ?, ?)
      `;
      
      console.log('üéì Ejecutando query CREATE carrera:', query);
      
      db.execute(
        query,
        [
          userId, nombre, numeroCarrera, cantidadAlumnos, duracionSemestres,
          modalidad, turno, descripcion, activa ? 1 : 0, 
          poblacionEsperada, poblacionReal, logo
        ],
        (err, results) => {
          if (err) {
            console.error('‚ùå Error en create carrera:', err);
            reject(err);
          } else {
            console.log('‚úÖ Carrera creada con ID:', results.insertId);
            resolve({ 
              id: results.insertId, 
              ...careerData,
              fechaRegistro: new Date().toISOString().split('T')[0],
              createdAt: new Date().toISOString()
            });
          }
        }
      );
    });
  },

  // Obtener carreras por usuario
  findByUserId: async (userId) => {
    return new Promise((resolve, reject) => {
      const query = `
        SELECT id, user_id, nombre, numero_carrera, cantidad_alumnos, 
               duracion_semestres, modalidad, turno, fecha_registro, 
               descripcion, activa, poblacion_esperada, poblacion_real, 
               logo, created_at, updated_at 
        FROM careers 
        WHERE user_id = ? 
        ORDER BY created_at DESC
      `;
      
      console.log('üéì Ejecutando query FIND BY USER ID:', query, [userId]);
      
      db.execute(query, [userId], (err, results) => {
        if (err) {
          console.error('‚ùå Error en findByUserId:', err);
          reject(err);
        } else {
          console.log('‚úÖ Resultado findByUserId:', results.length, 'carreras para usuario', userId);
          
          const careers = results.map(career => ({
            id: career.id,
            userId: career.user_id,
            nombre: career.nombre,
            numeroCarrera: career.numero_carrera,
            cantidadAlumnos: career.cantidad_alumnos,
            duracionSemestres: career.duracion_semestres,
            modalidad: career.modalidad,
            turno: career.turno,
            fechaRegistro: career.fecha_registro,
            descripcion: career.descripcion,
            activa: career.activa === 1,
            poblacionEsperada: career.poblacion_esperada,
            poblacionReal: career.poblacion_real,
            logo: career.logo,
            createdAt: career.created_at,
            updatedAt: career.updated_at
          }));
          
          resolve(careers);
        }
      });
    });
  },

  // Obtener carreras disponibles
  findAvailable: async () => {
    return new Promise((resolve, reject) => {
      const query = `
        SELECT id, user_id, nombre, numero_carrera, cantidad_alumnos, 
               duracion_semestres, modalidad, turno, fecha_registro, 
               descripcion, activa, poblacion_esperada, poblacion_real, 
               logo, created_at, updated_at 
        FROM careers 
        WHERE activa = 1 
        ORDER BY nombre
      `;
      
      console.log('üéì Ejecutando query FIND AVAILABLE:', query);
      
      db.execute(query, (err, results) => {
        if (err) {
          console.error('‚ùå Error en findAvailable:', err);
          reject(err);
        } else {
          console.log('‚úÖ Resultado findAvailable:', results.length, 'carreras disponibles');
          
          const careers = results.map(career => ({
            id: career.id,
            userId: career.user_id,
            nombre: career.nombre,
            numeroCarrera: career.numero_carrera,
            cantidadAlumnos: career.cantidad_alumnos,
            duracionSemestres: career.duracion_semestres,
            modalidad: career.modalidad,
            turno: career.turno,
            fechaRegistro: career.fecha_registro,
            descripcion: career.descripcion,
            activa: career.activa === 1,
            poblacionEsperada: career.poblacion_esperada,
            poblacionReal: career.poblacion_real,
            logo: career.logo,
            createdAt: career.created_at,
            updatedAt: career.updated_at
          }));
          
          resolve(careers);
        }
      });
    });
  },

  // Obtener carrera por ID
  findById: async (id) => {
    return new Promise((resolve, reject) => {
      const query = `
        SELECT id, user_id, nombre, numero_carrera, cantidad_alumnos, 
               duracion_semestres, modalidad, turno, fecha_registro, 
               descripcion, activa, poblacion_esperada, poblacion_real, 
               logo, created_at, updated_at 
        FROM careers 
        WHERE id = ?
      `;
      
      console.log('üéì Ejecutando query FIND BY ID:', query, [id]);
      
      db.execute(query, [id], (err, results) => {
        if (err) {
          console.error('‚ùå Error en findById:', err);
          reject(err);
        } else {
          if (results.length === 0) {
            console.log('‚ùå Carrera no encontrada con ID:', id);
            resolve(null);
            return;
          }
          
          const career = results[0];
          const mappedCareer = {
            id: career.id,
            userId: career.user_id,
            nombre: career.nombre,
            numeroCarrera: career.numero_carrera,
            cantidadAlumnos: career.cantidad_alumnos,
            duracionSemestres: career.duracion_semestres,
            modalidad: career.modalidad,
            turno: career.turno,
            fechaRegistro: career.fecha_registro,
            descripcion: career.descripcion,
            activa: career.activa === 1,
            poblacionEsperada: career.poblacion_esperada,
            poblacionReal: career.poblacion_real,
            logo: career.logo,
            createdAt: career.created_at,
            updatedAt: career.updated_at
          };
          
          console.log('‚úÖ Resultado findById:', mappedCareer);
          resolve(mappedCareer);
        }
      });
    });
  },

  // Actualizar carrera
  update: async (id, careerData) => {
    const {
      nombre,
      numeroCarrera,
      cantidadAlumnos,
      duracionSemestres,
      modalidad,
      turno,
      descripcion,
      activa,
      poblacionEsperada,
      poblacionReal,
      logo
    } = careerData;

    return new Promise((resolve, reject) => {
      const query = `
        UPDATE careers 
        SET nombre = ?, numero_carrera = ?, cantidad_alumnos = ?, 
            duracion_semestres = ?, modalidad = ?, turno = ?, 
            descripcion = ?, activa = ?, poblacion_esperada = ?, 
            poblacion_real = ?, logo = ?, updated_at = CURRENT_TIMESTAMP 
        WHERE id = ?
      `;
      
      console.log('üéì Ejecutando query UPDATE carrera:', query);
      
      db.execute(
        query,
        [
          nombre, numeroCarrera, cantidadAlumnos, duracionSemestres,
          modalidad, turno, descripcion, activa ? 1 : 0, 
          poblacionEsperada, poblacionReal, logo, id
        ],
        (err, results) => {
          if (err) {
            console.error('‚ùå Error en update carrera:', err);
            reject(err);
          } else {
            console.log('‚úÖ Resultado update carrera:', results);
            resolve(results);
          }
        }
      );
    });
  },

  // Actualizar solo m√©tricas
  updateMetrics: async (id, metricsData) => {
    const { poblacionEsperada, poblacionReal } = metricsData;
    
    return new Promise((resolve, reject) => {
      const query = `
        UPDATE careers 
        SET poblacion_esperada = ?, poblacion_real = ?, updated_at = CURRENT_TIMESTAMP 
        WHERE id = ?
      `;
      
      console.log('üéì Ejecutando query UPDATE metrics:', query);
      
      db.execute(
        query,
        [poblacionEsperada, poblacionReal, id],
        (err, results) => {
          if (err) {
            console.error('‚ùå Error en update metrics:', err);
            reject(err);
          } else {
            console.log('‚úÖ Resultado update metrics:', results);
            resolve(results);
          }
        }
      );
    });
  },

  // Actualizar solo logo
  updateLogo: async (id, logo) => {
    return new Promise((resolve, reject) => {
      const query = `
        UPDATE careers 
        SET logo = ?, updated_at = CURRENT_TIMESTAMP 
        WHERE id = ?
      `;
      
      console.log('üéì Ejecutando query UPDATE logo:', query);
      
      db.execute(
        query,
        [logo, id],
        (err, results) => {
          if (err) {
            console.error('‚ùå Error en update logo:', err);
            reject(err);
          } else {
            console.log('‚úÖ Resultado update logo:', results);
            resolve(results);
          }
        }
      );
    });
  },

  // Eliminar carrera
  delete: async (id) => {
    return new Promise((resolve, reject) => {
      const query = 'DELETE FROM careers WHERE id = ?';
      console.log('üéì Ejecutando query DELETE:', query, [id]);
      
      db.execute(query, [id], (err, results) => {
        if (err) {
          console.error('‚ùå Error en delete:', err);
          reject(err);
        } else {
          console.log('‚úÖ Resultado delete:', results);
          
          // Eliminar relaciones con instituciones
          const deleteRelationsQuery = 'DELETE FROM institution_careers WHERE career_id = ?';
          db.execute(deleteRelationsQuery, [id], (err2) => {
            if (err2) console.error('‚ùå Error eliminando relaciones:', err2);
          });
          
          resolve(results);
        }
      });
    });
  },

  // Buscar carreras por nombre
  search: async (searchTerm) => {
    return new Promise((resolve, reject) => {
      const query = `
        SELECT id, user_id, nombre, numero_carrera, cantidad_alumnos, 
               duracion_semestres, modalidad, turno, fecha_registro, 
               descripcion, activa, poblacion_esperada, poblacion_real, 
               logo, created_at, updated_at 
        FROM careers 
        WHERE nombre LIKE ? AND activa = 1 
        ORDER BY nombre
      `;
      
      console.log('üéì Ejecutando query SEARCH:', query, [`%${searchTerm}%`]);
      
      db.execute(query, [`%${searchTerm}%`], (err, results) => {
        if (err) {
          console.error('‚ùå Error en search:', err);
          reject(err);
        } else {
          console.log('‚úÖ Resultado search:', results.length, 'carreras');
          
          const careers = results.map(career => ({
            id: career.id,
            userId: career.user_id,
            nombre: career.nombre,
            numeroCarrera: career.numero_carrera,
            cantidadAlumnos: career.cantidad_alumnos,
            duracionSemestres: career.duracion_semestres,
            modalidad: career.modalidad,
            turno: career.turno,
            fechaRegistro: career.fecha_registro,
            descripcion: career.descripcion,
            activa: career.activa === 1,
            poblacionEsperada: career.poblacion_esperada,
            poblacionReal: career.poblacion_real,
            logo: career.logo,
            createdAt: career.created_at,
            updatedAt: career.updated_at
          }));
          
          resolve(careers);
        }
      });
    });
  }
};

module.exports = Career;
const db = require('../config/database');

class Institution {
  // ‚úÖ Obtener instituciones por usuario
  static async findByUserId(userId) {
    try {
      const [rows] = await db.promise().query(
        'SELECT * FROM institutions WHERE user_id = ? ORDER BY created_at DESC',
        [userId]
      );
      
      // Obtener carreras para cada instituci√≥n
      for (let institution of rows) {
        const [careers] = await db.promise().query(
          `SELECT c.nombre FROM careers c
           INNER JOIN institution_careers ic ON c.id = ic.career_id
           WHERE ic.institution_id = ?`,
          [institution.id]
        );
        institution.carreras = careers.map(c => c.nombre);
      }
      
      return rows;
    } catch (error) {
      throw error;
    }
  }

  // ‚úÖ Obtener todas las instituciones
  static async findAll() {
    try {
      const [rows] = await db.promise().query(
        `SELECT i.*, u.nombre_completo as propietario 
         FROM institutions i
         LEFT JOIN users u ON i.user_id = u.id
         ORDER BY i.created_at DESC`
      );
      
      // Obtener carreras para cada instituci√≥n
      for (let institution of rows) {
        const [careers] = await db.promise().query(
          `SELECT c.nombre FROM careers c
           INNER JOIN institution_careers ic ON c.id = ic.career_id
           WHERE ic.institution_id = ?`,
          [institution.id]
        );
        institution.carreras = careers.map(c => c.nombre);
      }
      
      return rows;
    } catch (error) {
      throw error;
    }
  }

  // ‚úÖ Buscar por ID
  static async findById(id) {
    try {
      const [rows] = await db.promise().query(
        'SELECT * FROM institutions WHERE id = ?',
        [id]
      );
      
      if (rows.length === 0) return null;
      
      const institution = rows[0];
      
      // Obtener carreras
      const [careers] = await db.promise().query(
        `SELECT c.nombre FROM careers c
         INNER JOIN institution_careers ic ON c.id = ic.career_id
         WHERE ic.institution_id = ?`,
        [id]
      );
      institution.carreras = careers.map(c => c.nombre);
      
      return institution;
    } catch (error) {
      throw error;
    }
  }

  // ‚úÖ Verificar si CCT existe
  static async checkCCTExists(claveCCT, excludeId = null) {
    try {
      let query = 'SELECT id FROM institutions WHERE clave_cct = ?';
      const params = [claveCCT];
      
      if (excludeId) {
        query += ' AND id != ?';
        params.push(excludeId);
      }
      
      const [rows] = await db.promise().query(query, params);
      return rows.length > 0;
    } catch (error) {
      throw error;
    }
  }

  // ‚úÖ Crear instituci√≥n
  static async create(institutionData) {
    const { userId, nombre, claveCCT, telefono, extension, correo, 
            nombreRepresentante, puestoRepresentante, direccion, logo, estado } = institutionData;
    
    try {
      const [result] = await db.promise().query(
        `INSERT INTO institutions (user_id, nombre, clave_cct, telefono, extension, 
         correo, nombre_representante, puesto_representante, direccion, logo, estado, 
         created_at, updated_at) 
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
        [userId, nombre, claveCCT, telefono || null, extension || null, 
         correo || null, nombreRepresentante || null, puestoRepresentante || null, 
         direccion || null, logo || null, estado || 'active']
      );

      return {
        id: result.insertId,
        ...institutionData
      };
    } catch (error) {
      throw error;
    }
  }

  // ‚úÖ Actualizar instituci√≥n
  static async update(id, institutionData) {
    const { nombre, claveCCT, telefono, extension, correo, 
            nombreRepresentante, puestoRepresentante, direccion, logo, estado } = institutionData;
    
    try {
      await db.promise().query(
        `UPDATE institutions 
         SET nombre = ?, clave_cct = ?, telefono = ?, extension = ?, 
             correo = ?, nombre_representante = ?, puesto_representante = ?, 
             direccion = ?, logo = ?, estado = ?, updated_at = NOW()
         WHERE id = ?`,
        [nombre, claveCCT, telefono || null, extension || null, 
         correo || null, nombreRepresentante || null, puestoRepresentante || null,
         direccion || null, logo || null, estado || 'active', id]
      );

      return true;
    } catch (error) {
      throw error;
    }
  }

  // ‚úÖ Eliminar instituci√≥n
  static async delete(id) {
    try {
      const [result] = await db.promise().query(
        'DELETE FROM institutions WHERE id = ?',
        [id]
      );
      return result;
    } catch (error) {
      throw error;
    }
  }

  // ‚úÖ Buscar instituciones
  static async search(searchTerm) {
    try {
      const [rows] = await db.promise().query(
        `SELECT i.*, u.nombre_completo as propietario 
         FROM institutions i
         LEFT JOIN users u ON i.user_id = u.id
         WHERE i.nombre LIKE ? OR i.clave_cct LIKE ? OR i.correo LIKE ? 
            OR i.nombre_representante LIKE ? OR u.nombre_completo LIKE ?
         ORDER BY i.nombre`,
        [`%${searchTerm}%`, `%${searchTerm}%`, `%${searchTerm}%`, 
         `%${searchTerm}%`, `%${searchTerm}%`]
      );
      
      // Obtener carreras para cada instituci√≥n
      for (let institution of rows) {
        const [careers] = await db.promise().query(
          `SELECT c.nombre FROM careers c
           INNER JOIN institution_careers ic ON c.id = ic.career_id
           WHERE ic.institution_id = ?`,
          [institution.id]
        );
        institution.carreras = careers.map(c => c.nombre);
      }
      
      return rows;
    } catch (error) {
      throw error;
    }
  }

  // ‚úÖ Obtener estad√≠sticas
  static async getStats() {
    try {
      const [total] = await db.promise().query('SELECT COUNT(*) as total FROM institutions');
      const [active] = await db.promise().query("SELECT COUNT(*) as active FROM institutions WHERE estado = 'active'");
      const [withCareers] = await db.promise().query(
        'SELECT COUNT(DISTINCT institution_id) as with_careers FROM institution_careers'
      );
      
      return {
        totalInstitutions: total[0].total,
        activeInstitutions: active[0].active,
        inactiveInstitutions: total[0].total - active[0].active,
        institutionsWithCareers: withCareers[0].with_careers
      };
    } catch (error) {
      throw error;
    }
  }

  // ‚úÖ A√±adir relaci√≥n instituci√≥n-carrera
  static async addCareerRelation(institutionId, careerId) {
    try {
      await db.promise().query(
        'INSERT INTO institution_careers (institution_id, career_id) VALUES (?, ?)',
        [institutionId, careerId]
      );
      return true;
    } catch (error) {
      throw error;
    }
  }
}

module.exports = Institution;
const db = require('../config/database');
const bcrypt = require('bcryptjs');

class User {
    // ‚úÖ Crear usuario con validaci√≥n de n√∫mero de trabajador
    static async create(userData) {
        const { 
            username, 
            email, 
            password, 
            role, 
            nombreCompleto, 
            telefono, 
            institucion, 
            avatar,
            numeroTrabajador 
        } = userData;
        
        try {
            // Verificar si el usuario ya existe por email
            const [existingUser] = await db.promise().query(
                'SELECT id FROM users WHERE email = ?',
                [email]
            );

            if (existingUser.length > 0) {
                throw new Error('El usuario con este email ya existe');
            }

            // Verificar n√∫mero de trabajador si es admin
            if (role === 'admin' && numeroTrabajador) {
                const [existingWorker] = await db.promise().query(
                    'SELECT id FROM users WHERE numero_trabajador = ?',
                    [numeroTrabajador]
                );

                if (existingWorker.length > 0) {
                    throw new Error('El n√∫mero de trabajador ya existe');
                }
            }

            // Hash de la contrase√±a
               const hashedPassword = await bcrypt.hash(password, 10);

            // Insertar usuario
            const [result] = await db.promise().query(
                `INSERT INTO users (
                    username, email, password, role, nombre_completo, 
                    telefono, institucion, avatar, numero_trabajador, 
                    is_active, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 1, NOW(), NOW())`,
                [
                    username, email, hashedPassword, role, nombreCompleto, 
                    telefono, institucion, avatar, numeroTrabajador || null
                ]
            );

            return {
                id: result.insertId,
                username,
                email,
                role,
                nombre_completo: nombreCompleto,
                telefono,
                institucion,
                avatar,
                numero_trabajador: numeroTrabajador,
                is_active: 1,
                created_at: new Date(),
                updated_at: new Date()
            };
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Buscar por email
    static async findByEmail(email) {
        try {
            const [rows] = await db.promise().query(
                'SELECT * FROM users WHERE email = ?',
                [email]
            );
            return rows[0] || null;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Buscar por ID
    static async findById(id) {
        try {
            const [rows] = await db.promise().query(
                'SELECT * FROM users WHERE id = ?',
                [id]
            );
            return rows[0] || null;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Buscar por n√∫mero de trabajador
    static async findByWorkerNumber(numeroTrabajador) {
        try {
            const [rows] = await db.promise().query(
                'SELECT * FROM users WHERE numero_trabajador = ?',
                [numeroTrabajador]
            );
            return rows[0] || null;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Actualizar usuario
    static async update(id, updateData) {
        const { 
            nombreCompleto, 
            telefono, 
            institucion, 
            numeroTrabajador 
        } = updateData;
        
        try {
            let query = `UPDATE users 
                         SET nombre_completo = ?, telefono = ?, institucion = ?, 
                         updated_at = NOW()`;
            let params = [nombreCompleto, telefono, institucion];

            if (numeroTrabajador !== undefined) {
                query += ', numero_trabajador = ?';
                params.push(numeroTrabajador);
            }

            query += ' WHERE id = ?';
            params.push(id);

            await db.promise().query(query, params);
            return true;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Actualizar avatar
    static async updateAvatar(id, avatar) {
        try {
            await db.promise().query(
                'UPDATE users SET avatar = ?, updated_at = NOW() WHERE id = ?',
                [avatar, id]
            );
            return true;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Cambiar contrase√±a
    static async updatePassword(id, currentPassword, newPassword) {
        try {
            // Obtener usuario actual
            const user = await this.findById(id);
            if (!user) {
                throw new Error('Usuario no encontrado');
            }

            // Verificar contrase√±a actual
            const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
            if (!isPasswordValid) {
                throw new Error('La contrase√±a actual es incorrecta');
            }

            // Hash de nueva contrase√±a
            const hashedPassword = await bcrypt.hash(newPassword, 10);

            // Actualizar contrase√±a
            await db.promise().query(
                'UPDATE users SET password = ?, updated_at = NOW() WHERE id = ?',
                [hashedPassword, id]
            );

            return true;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Obtener avatar
    static async getAvatar(id) {
        try {
            const [rows] = await db.promise().query(
                'SELECT avatar FROM users WHERE id = ?',
                [id]
            );
            return rows[0]?.avatar || null;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Obtener todos los usuarios
    static async findAll() {
        try {
            const [rows] = await db.promise().query(
                'SELECT * FROM users ORDER BY created_at DESC'
            );
            return rows;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Actualizar rol (con n√∫mero de trabajador si es admin)
    static async updateRole(id, role, numeroTrabajador = null) {
        try {
            let query = 'UPDATE users SET role = ?, updated_at = NOW()';
            let params = [role];

            if (role === 'admin' && numeroTrabajador) {
                query += ', numero_trabajador = ?';
                params.push(numeroTrabajador);
            } else if (role === 'user') {
                query += ', numero_trabajador = NULL';
            }

            query += ' WHERE id = ?';
            params.push(id);

            await db.promise().query(query, params);
            return true;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Eliminar usuario
    static async delete(id) {
        try {
            const [result] = await db.promise().query(
                'DELETE FROM users WHERE id = ?',
                [id]
            );
            return result;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Buscar usuarios
    static async search(searchTerm) {
        try {
            const [rows] = await db.promise().query(
                `SELECT * FROM users 
                 WHERE email LIKE ? OR username LIKE ? OR nombre_completo LIKE ?
                    OR numero_trabajador LIKE ?
                 ORDER BY created_at DESC`,
                [
                    `%${searchTerm}%`, 
                    `%${searchTerm}%`, 
                    `%${searchTerm}%`,
                    `%${searchTerm}%`
                ]
            );
            return rows;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Obtener estad√≠sticas
    static async getStats() {
        try {
            const [total] = await db.promise().query('SELECT COUNT(*) as total FROM users');
            const [admins] = await db.promise().query("SELECT COUNT(*) as admins FROM users WHERE role = 'admin'");
            const [active] = await db.promise().query('SELECT COUNT(*) as active FROM users WHERE is_active = 1');
            const [withWorkerNumber] = await db.promise().query(
                'SELECT COUNT(*) as with_worker FROM users WHERE numero_trabajador IS NOT NULL'
            );
            
            return {
                totalUsers: total[0].total,
                totalAdmins: admins[0].admins,
                totalNormalUsers: total[0].total - admins[0].admins,
                activeUsers: active[0].active,
                inactiveUsers: total[0].total - active[0].active,
                usersWithWorkerNumber: withWorkerNumber[0].with_worker
            };
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Activar/desactivar usuario
    static async toggleStatus(id, isActive) {
        try {
            await db.promise().query(
                'UPDATE users SET is_active = ?, updated_at = NOW() WHERE id = ?',
                [isActive ? 1 : 0, id]
            );
            return true;
        } catch (error) {
            throw error;
        }
    }

    // ‚úÖ Obtener usuarios por rol
    static async findByRole(role) {
        try {
            const [rows] = await db.promise().query(
                'SELECT * FROM users WHERE role = ? ORDER BY nombre_completo',
                [role]
            );
            return rows;
        } catch (error) {
            throw error;
        }
    }
}

module.exports = User;
const express = require('express');
const router = express.Router();
const AuthController = require('../controllers/authController');
const { authorize } = require('../middleware/auth');

// ============================================
// RUTAS P√öBLICAS (NO requieren token)
// ============================================
router.post('/register', AuthController.register);
router.post('/login', AuthController.login);

// ============================================
// RUTAS PROTEGIDAS (requieren token)
// ============================================
router.get('/profile', authorize(), AuthController.getProfile);
router.get('/verify', authorize(), AuthController.verify);
router.put('/profile', authorize(), AuthController.updateProfile); // ‚úÖ AGREGADA
router.put('/avatar', authorize(), AuthController.updateAvatar);   // ‚úÖ AGREGADA
router.put('/change-password', authorize(), AuthController.changePassword); // ‚úÖ AGREGADA
router.put('/update-full-profile', authorize(), AuthController.updateFullProfile); // ‚úÖ AGREGADA

// ============================================
// RUTAS SOLO PARA ADMIN (requieren token Y rol admin)
// ============================================
router.get('/users', authorize(['admin']), AuthController.getAllUsers);

module.exports = router;
const express = require('express');
const router = express.Router();
const CareerController = require('../controllers/careerController');
const { authorize } = require('../middleware/auth');

// RUTAS PROTEGIDAS (requieren autenticaci√≥n)
router.get('/my', authorize(), CareerController.getByUser);
router.get('/available', CareerController.getAvailable); // P√∫blica
router.post('/', authorize(), CareerController.create);
router.get('/:id', authorize(), CareerController.getById);
router.put('/:id', authorize(), CareerController.update);
router.put('/:id/metrics', authorize(), CareerController.updateMetrics);
router.delete('/:id', authorize(), CareerController.delete);
router.get('/stats/stats', authorize(), CareerController.getStats);

// RUTAS SOLO PARA ADMIN
router.get('/', authorize(['admin']), CareerController.getAll);

module.exports = router;
const express = require('express');
const router = express.Router();
const InstitutionController = require('../controllers/institutionController');
const { authorize } = require('../middleware/auth');

// RUTAS PROTEGIDAS (requieren autenticaci√≥n)
router.get('/my', authorize(), InstitutionController.getByUser);
router.post('/', authorize(), InstitutionController.create);
router.get('/:id', authorize(), InstitutionController.getById);
router.put('/:id', authorize(), InstitutionController.update);
router.delete('/:id', authorize(), InstitutionController.delete);

// RUTAS PARA TECNOL√ìGICOS PRE-REGISTRADOS
router.get('/pre-registered/list', authorize(), InstitutionController.getPreRegisteredInstitutions);
router.post('/pre-registered/load', authorize(), InstitutionController.loadPreRegisteredInstitutions);

// RUTAS DE EXPORTACI√ìN
router.get('/export/data', authorize(), InstitutionController.exportData);

// RUTAS SOLO PARA ADMIN
router.get('/', authorize(['admin']), InstitutionController.getAll);
router.get('/statistics/stats', authorize(['admin']), InstitutionController.getStatistics);

module.exports = router;

y este es mi frotend
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { BehaviorSubject, Observable, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { Router } from '@angular/router';
import { environment } from '../../environments/environments';
import { 
  User, 
  LoginRequest, 
  RegisterRequestWithRole,
  AuthResponse, 
  ProfileResponse, 
  ProfileUpdate, 
  PasswordChange,
  UsersResponse,
  UserStats,
} from '../models/user.model';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private apiUrl = environment.apiUrl;
  private currentUserSubject: BehaviorSubject<User | null>;
  public currentUser: Observable<User | null>;

  constructor(
    private http: HttpClient,
    private router: Router
  ) {
    // Inicializar el BehaviorSubject con usuario del localStorage
    this.currentUserSubject = new BehaviorSubject<User | null>(this.getUserFromStorage());
    this.currentUser = this.currentUserSubject.asObservable();
    
    // Verificar token al iniciar
    this.autoVerifyToken();
  }

  public get currentUserValue(): User | null {
    return this.currentUserSubject.value;
  }

  private autoVerifyToken(): void {
    const token = this.getToken();
    if (token && this.currentUserValue) {
      this.verifyToken().subscribe({
        next: (response) => {
          if (response.success && response.user) {
            this.saveUserData(response.user);
            console.log('‚úÖ Token verificado autom√°ticamente');
          }
        },
        error: (error) => {
          console.error('‚ùå Token inv√°lido:', error);
          this.logout();
        }
      });
    }
  }

  // M√©todo p√∫blico para obtener headers
  getHeaders(): HttpHeaders {
    const token = this.getToken();
    
    let headers = new HttpHeaders({
      'Content-Type': 'application/json'
    });

    if (token) {
      headers = headers.set('Authorization', `Bearer ${token}`);
    }

    return headers;
  }

  getToken(): string {
    return localStorage.getItem('token') || '';
  }

  private saveAuthData(token: string, user: User): void {
    localStorage.setItem('token', token);
    localStorage.setItem('user', JSON.stringify(user));
    this.currentUserSubject.next(user);
  }

 

  private clearAuthData(): void {
    localStorage.removeItem('token');
    localStorage.removeItem('user');
    this.currentUserSubject.next(null);
  }

  private getUserFromStorage(): User | null {
    const userStr = localStorage.getItem('user');
    return userStr ? JSON.parse(userStr) : null;
  }

  // ‚úÖ Verificar autenticaci√≥n
  isAuthenticated(): boolean {
    return !!this.getToken();
  }

  // ‚úÖ Verificar si es administrador
  isAdmin(): boolean {
    const user = this.currentUserValue;
    return user ? user.role === 'admin' : false;
  }

  // ‚úÖ Login - SIMPLIFICADO Y CORREGIDO
  login(email: string, password: string): Observable<AuthResponse> {
    const headers = new HttpHeaders({ 'Content-Type': 'application/json' });
    
    return this.http.post<AuthResponse>(
      `${this.apiUrl}/auth/login`,
      { email, password },
      { headers }
    ).pipe(
      map(response => {
        console.log('üîê Login response:', response);
        
        if (response.success && response.user && response.token) {
          this.saveAuthData(response.token, response.user);
          console.log('‚úÖ Login exitoso, datos guardados');
        }
        return response;
      }),
      catchError(error => {
        console.error('‚ùå Error en login:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Registro
  register(userData: RegisterRequestWithRole): Observable<AuthResponse> {
    const headers = new HttpHeaders({ 'Content-Type': 'application/json' });
    
    return this.http.post<AuthResponse>(
      `${this.apiUrl}/auth/register`,
      userData,
      { headers }
    ).pipe(
      map(response => {
        if (response.success && response.user && response.token) {
          this.saveAuthData(response.token, response.user);
        }
        return response;
      }),
      catchError(error => {
        console.error('‚ùå Error en registro:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Verificar token
  verifyToken(): Observable<any> {
    const headers = this.getHeaders();
    
    return this.http.get(`${this.apiUrl}/auth/verify`, { headers }).pipe(
      map(response => response),
      catchError(error => {
        console.error('‚ùå Error verificando token:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Logout
  logout(): void {
    this.clearAuthData();
    this.router.navigate(['/login']);
  }

  // ‚úÖ Obtener perfil
  getProfile(): Observable<ProfileResponse> {
    const headers = this.getHeaders();
    
    return this.http.get<ProfileResponse>(
      `${this.apiUrl}/auth/profile`,
      { headers }
    ).pipe(
      map(response => {
        if (response.success && response.user) {
          this.saveUserData(response.user);
        }
        return response;
      }),
      catchError(error => {
        console.error('‚ùå Error obteniendo perfil:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Actualizar perfil
// ... otros m√©todos ...

// ‚úÖ Actualizar perfil (completo con datos + avatar + password si es necesario)
updateProfile(profileData: any): Observable<any> {
    const headers = this.getHeaders();
    
    return this.http.put<any>(
      `${this.apiUrl}/auth/update-full-profile`,
      profileData,
      { headers }
    ).pipe(
      map(response => {
        if (response.success && response.user) {
          this.saveUserData(response.user);
        }
        return response;
      }),
      catchError(error => {
        console.error('‚ùå Error actualizando perfil:', error);
        return throwError(() => error);
      })
    );
}

// M√©todo para guardar usuario actualizado
     public saveUserData(user: User): void {
    localStorage.setItem('user', JSON.stringify(user));
    this.currentUserSubject.next(user);
}

  // ‚úÖ Actualizar avatar
  updateAvatar(avatar: string): Observable<ProfileResponse> {
    const headers = this.getHeaders();
    
    return this.http.put<ProfileResponse>(
      `${this.apiUrl}/auth/avatar`,
      { avatar },
      { headers }
    ).pipe(
      map(response => {
        if (response.success && response.user) {
          localStorage.setItem('user', JSON.stringify(response.user));
          this.currentUserSubject.next(response.user);
        }
        return response;
      }),
      catchError(error => {
        console.error('‚ùå Error actualizando avatar:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Cambiar contrase√±a
  changePassword(passwordData: PasswordChange): Observable<ProfileResponse> {
    const headers = this.getHeaders();
    
    return this.http.put<ProfileResponse>(
      `${this.apiUrl}/auth/change-password`,
      passwordData,
      { headers }
    ).pipe(
      catchError(error => {
        console.error('‚ùå Error cambiando contrase√±a:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Obtener todos los usuarios (solo admin)
  getAllUsers(): Observable<UsersResponse> {
    const headers = this.getHeaders();
    
    return this.http.get<UsersResponse>(
      `${this.apiUrl}/auth/users`,
      { headers }
    ).pipe(
      catchError(error => {
        console.error('‚ùå Error obteniendo usuarios:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Obtener estad√≠sticas de usuarios (solo admin)
  getUserStats(): Observable<{success: boolean, stats?: UserStats, message?: string}> {
    const headers = this.getHeaders();
    
    return this.http.get<{success: boolean, stats?: UserStats, message?: string}>(
      `${this.apiUrl}/auth/stats`,
      { headers }
    ).pipe(
      catchError(error => {
        console.error('‚ùå Error obteniendo estad√≠sticas:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Actualizar rol de usuario (solo admin)
  updateUserRole(userId: number, role: string, adminKey?: string, numeroTrabajador?: string): 
    Observable<{success: boolean, message: string}> {
    
    const headers = this.getHeaders();
    const body: any = { role };
    
    if (role === 'admin') {
      body.adminKey = adminKey;
      body.numeroTrabajador = numeroTrabajador;
    }
    
    return this.http.put<{success: boolean, message: string}>(
      `${this.apiUrl}/auth/users/${userId}/role`,
      body,
      { headers }
    ).pipe(
      catchError(error => {
        console.error('‚ùå Error actualizando rol:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Eliminar usuario (solo admin)
  deleteUser(userId: number): Observable<{success: boolean, message: string}> {
    const headers = this.getHeaders();
    
    return this.http.delete<{success: boolean, message: string}>(
      `${this.apiUrl}/auth/users/${userId}`,
      { headers }
    ).pipe(
      catchError(error => {
        console.error('‚ùå Error eliminando usuario:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Buscar usuarios (solo admin)
  searchUsers(searchTerm: string): Observable<UsersResponse> {
    const headers = this.getHeaders();
    
    return this.http.get<UsersResponse>(
      `${this.apiUrl}/auth/search?search=${encodeURIComponent(searchTerm)}`,
      { headers }
    ).pipe(
      catchError(error => {
        console.error('‚ùå Error buscando usuarios:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Activar/desactivar usuario (solo admin)
  toggleUserStatus(userId: number, isActive: boolean): Observable<{success: boolean, message: string}> {
    const headers = this.getHeaders();
    
    return this.http.put<{success: boolean, message: string}>(
      `${this.apiUrl}/auth/users/${userId}/status`,
      { isActive },
      { headers }
    ).pipe(
      catchError(error => {
        console.error('‚ùå Error cambiando estado:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ M√©todo para refrescar datos de usuario
  refreshUserData(): Observable<AuthResponse> {
    const headers = this.getHeaders();
    
    return this.http.get<AuthResponse>(
      `${this.apiUrl}/auth/verify`,
      { headers }
    ).pipe(
      map(response => {
        if (response.success && response.user) {
          this.saveUserData(response.user);
        }
        return response;
      }),
      catchError(error => {
        console.error('‚ùå Error refrescando datos:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Verificar si necesita actualizar perfil
  needsProfileUpdate(): boolean {
    const user = this.currentUserValue;
    if (!user) return false;
    
    // Verificar si tiene datos b√°sicos completos
    return !user.nombreCompleto || !user.telefono || !user.institucion;
  }

  // ‚úÖ Obtener avatar
  getAvatar(userId: number): Observable<any> {
    return this.http.get(`${this.apiUrl}/auth/avatar/${userId}`, { responseType: 'blob' }).pipe(
      catchError(error => {
        console.error('‚ùå Error obteniendo avatar:', error);
        return throwError(() => error);
      })
    );
  }
}
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { environment } from '../../environments/environments';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root'
})
export class CareerService {
  private apiUrl = environment.apiUrl;

  constructor(private http: HttpClient, private authService: AuthService) {}

  // ‚úÖ Obtener carreras del usuario actual
  getMyCareers(): Observable<any> {
    const headers = this.authService.getHeaders();
    
    return this.http.get(`${this.apiUrl}/careers/my`, { headers }).pipe(
      map((response: any) => {
        console.log('üéì Respuesta de mis carreras:', response);
        return {
          success: response.success || true,
          data: response.data || response.careers || [],
          count: response.count || 0,
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error cargando mis carreras:', error);
        return of({
          success: false,
          message: 'Error al cargar mis carreras',
          data: []
        });
      })
    );
  }

  // ‚úÖ Obtener carreras disponibles (p√∫blico)
  getAvailableCareers(): Observable<any> {
    return this.http.get(`${this.apiUrl}/careers/available`).pipe(
      map((response: any) => {
        console.log('üéì Respuesta de carreras disponibles:', response);
        return {
          success: response.success || true,
          data: response.data || response.careers || [],
          count: response.count || 0,
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error cargando carreras disponibles:', error);
        return of({
          success: false,
          message: 'Error al cargar carreras disponibles',
          data: []
        });
      })
    );
  }

  // ‚úÖ Crear carrera
// En tu career.service.ts - m√©todo createCareer
// En el m√©todo createCareer - aseg√∫rate de enviar todos los campos
createCareer(careerData: any): Observable<any> {
  const headers = this.authService.getHeaders();
  
  // Asegurar que todos los campos est√©n presentes
  const completeCareerData = {
    nombre: careerData.nombre,
    numeroCarrera: careerData.numeroCarrera,
    cantidadAlumnos: careerData.cantidadAlumnos || 0,
    duracionSemestres: careerData.duracionSemestres || 8,
    modalidad: careerData.modalidad || 'Escolarizada',
    turno: careerData.turno || 'Matutino',
    descripcion: careerData.descripcion || '',
    activa: careerData.activa !== undefined ? careerData.activa : true,
    poblacionEsperada: careerData.poblacionEsperada || 100,
    poblacionReal: careerData.poblacionReal || 50,
    logo: careerData.logo || null
  };
  
  console.log('üì§ Enviando datos completos de carrera:', completeCareerData);
  
  return this.http.post(
    `${this.apiUrl}/careers`,
    completeCareerData,
    { headers }
  ).pipe(
    map((response: any) => {
      console.log('‚úÖ Respuesta crear carrera:', response);
      return {
        success: response.success || true,
        career: response.career || response.data,
        message: response.message || 'Carrera creada exitosamente'
      };
    }),
    catchError(error => {
      console.error('‚ùå Error creando carrera:', error);
      let errorMessage = 'Error al crear carrera';
      
      if (error.status === 400) {
        errorMessage = error.error?.message || 'Datos inv√°lidos';
      }
      
      return of({
        success: false,
        message: errorMessage
      });
    })
  );
}

// A√±ade m√©todo espec√≠fico para actualizar m√©tricas
updateCareerMetrics(id: number, poblacionEsperada: number, poblacionReal: number): Observable<any> {
  const headers = this.authService.getHeaders();
  const metricsData = { 
    poblacionEsperada, 
    poblacionReal 
  };
  
  console.log('üìà Actualizando m√©tricas para carrera', id, ':', metricsData);
  
  return this.http.put(
    `${this.apiUrl}/careers/${id}/metrics`, 
    metricsData, 
    { headers }
  ).pipe(
    map((response: any) => {
      console.log('‚úÖ Respuesta actualizar m√©tricas:', response);
      return {
        success: response.success || true,
        message: response.message || 'M√©tricas actualizadas exitosamente'
      };
    }),
    catchError(error => {
      console.error('‚ùå Error actualizando m√©tricas:', error);
      return of({
        success: false,
        message: 'Error al actualizar m√©tricas'
      });
    })
  );
}

  // ‚úÖ Actualizar carrera
  updateCareer(id: number, careerData: any): Observable<any> {
    const headers = this.authService.getHeaders();
    
    return this.http.put(
      `${this.apiUrl}/careers/${id}`,
      careerData,
      { headers }
    ).pipe(
      map((response: any) => {
        console.log('‚úèÔ∏è Respuesta actualizar carrera:', response);
        return {
          success: response.success || true,
          career: response.career || response.data,
          message: response.message || 'Carrera actualizada exitosamente'
        };
      }),
      catchError(error => {
        console.error('‚ùå Error actualizando carrera:', error);
        return of({
          success: false,
          message: 'Error al actualizar carrera'
        });
      })
    );
  }

  // ‚úÖ Obtener carrera por ID
  getCareerById(id: number): Observable<any> {
    const headers = this.authService.getHeaders();
    
    return this.http.get(`${this.apiUrl}/careers/${id}`, { headers }).pipe(
      map((response: any) => {
        console.log('üéì Respuesta carrera por ID:', response);
        return {
          success: response.success || true,
          data: response.career || response.data,
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error obteniendo carrera:', error);
        return of({
          success: false,
          message: 'Error al obtener carrera'
        });
      })
    );
  }

  

  // ‚úÖ Eliminar carrera
  deleteCareer(id: number): Observable<any> {
    const headers = this.authService.getHeaders();
    
    return this.http.delete(
      `${this.apiUrl}/careers/${id}`,
      { headers }
    ).pipe(
      map((response: any) => {
        console.log('üóëÔ∏è Respuesta eliminar carrera:', response);
        return {
          success: response.success || true,
          message: response.message || 'Carrera eliminada exitosamente'
        };
      }),
      catchError(error => {
        console.error('‚ùå Error eliminando carrera:', error);
        return of({
          success: false,
          message: 'Error al eliminar carrera'
        });
      })
    );
  }

  // ‚úÖ Buscar carreras
  searchCareers(searchTerm: string): Observable<any> {
    const headers = this.authService.getHeaders();
    
    return this.http.get(`${this.apiUrl}/careers/search?q=${encodeURIComponent(searchTerm)}`, { headers }).pipe(
      map((response: any) => {
        console.log('üîç Resultados de b√∫squeda de carreras:', response);
        return {
          success: response.success || true,
          data: response.data || response.careers || [],
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error buscando carreras:', error);
        return of({
          success: false,
          message: 'Error al buscar carreras',
          data: []
        });
      })
    );
  }

  // ‚úÖ Obtener estad√≠sticas de carreras
  getCareerStatistics(): Observable<any> {
    const headers = this.authService.getHeaders();
    
    return this.http.get(`${this.apiUrl}/careers/stats`, { headers }).pipe(
      map((response: any) => {
        console.log('üìä Estad√≠sticas de carreras:', response);
        return {
          success: response.success || true,
          statistics: response.statistics || response.data,
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error obteniendo estad√≠sticas:', error);
        return of({
          success: false,
          message: 'Error al obtener estad√≠sticas'
        });
      })
    );
  }

  // ‚úÖ Obtener todas las carreras (solo admin)
  getAllCareers(): Observable<any> {
    const headers = this.authService.getHeaders();
    
    return this.http.get(`${this.apiUrl}/careers/all`, { headers }).pipe(
      map((response: any) => {
        console.log('üéì Todas las carreras:', response);
        return {
          success: response.success || true,
          data: response.data || response.careers || [],
          count: response.count || 0,
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error obteniendo todas las carreras:', error);
        return of({
          success: false,
          message: 'Error al obtener todas las carreras',
          data: []
        });
      })
    );
  }

  // ‚úÖ M√©todos para compatibilidad
  getMyCareersWithUserId(userId: number): Observable<any> {
    return this.getMyCareers();
  }

  createCareerWithUserId(careerData: any, userId: number): Observable<any> {
    return this.createCareer(careerData);
  }

  // ‚úÖ Actualizar logo de carrera
  updateCareerLogo(id: number, logo: string): Observable<any> {
    const headers = this.authService.getHeaders();
    const logoData = { logo };
    
    return this.http.put(
      `${this.apiUrl}/careers/${id}/logo`,
      logoData,
      { headers }
    ).pipe(
      map((response: any) => {
        console.log('üñºÔ∏è Respuesta actualizar logo:', response);
        return {
          success: response.success || true,
          message: response.message || 'Logo actualizado exitosamente'
        };
      }),
      catchError(error => {
        console.error('‚ùå Error actualizando logo:', error);
        return of({
          success: false,
          message: 'Error al actualizar logo'
        });
      })
    );
  }
}import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, of, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { environment } from '../../environments/environments';
import { AuthService } from './auth.service';
import * as XLSX from 'xlsx';

@Injectable({
  providedIn: 'root'
})
export class InstitutionService {
  private apiUrl = environment.apiUrl;

  constructor(private http: HttpClient, private authService: AuthService) {}

  private getHeaders(): HttpHeaders {
    return this.authService.getHeaders();
  }

  // ‚úÖ Obtener instituciones del usuario actual
  getMyInstitutions(): Observable<any> {
    const headers = this.getHeaders();
    
    return this.http.get(`${this.apiUrl}/institutions/my`, { headers }).pipe(
      map((response: any) => {
        console.log('üìä Respuesta de instituciones (my):', response);
        return {
          success: response.success || true,
          institutions: response.institutions || response.data || [],
          count: response.count || 0,
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error obteniendo mis instituciones:', error);
        return of({
          success: false,
          message: 'Error obteniendo instituciones',
          institutions: []
        });
      })
    );
  }

  // ‚úÖ Obtener todas las instituciones (solo admin)
  getAllInstitutions(): Observable<any> {
    const headers = this.getHeaders();
    
    return this.http.get(`${this.apiUrl}/institutions`, { headers }).pipe(
      map((response: any) => {
        console.log('üìä Respuesta de todas las instituciones:', response);
        return {
          success: response.success || true,
          institutions: response.institutions || response.data || [],
          count: response.count || 0,
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error obteniendo todas las instituciones:', error);
        return throwError(() => error);
      })
    );
  }

  // ‚úÖ Obtener instituci√≥n por ID
  getInstitutionById(id: number): Observable<any> {
    const headers = this.getHeaders();
    
    return this.http.get(`${this.apiUrl}/institutions/${id}`, { headers }).pipe(
      map((response: any) => {
        console.log('üìä Respuesta de instituci√≥n por ID:', response);
        return {
          success: response.success || true,
          institution: response.institution || response.data,
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error obteniendo instituci√≥n:', error);
        return of({
          success: false,
          message: 'Error obteniendo instituci√≥n'
        });
      })
    );
  }

  // ‚úÖ Crear instituci√≥n
  // ‚úÖ Crear instituci√≥n - VERSI√ìN CORREGIDA
createInstitution(institutionData: any): Observable<any> {
  const headers = this.getHeaders();
  
  console.log('üì§ Enviando datos de instituci√≥n:', institutionData);
  console.log('üéì Carreras a enviar (deben ser IDs):', institutionData.carreras);
  
  return this.http.post(
    `${this.apiUrl}/institutions`,
    institutionData,
    { headers }
  ).pipe(
    map((response: any) => {
      console.log('üìä Respuesta crear instituci√≥n:', response);
      return {
        success: response.success || true,
        institution: response.institution || response.data,
        message: response.message || 'Instituci√≥n creada exitosamente'
      };
    }),
    catchError(error => {
      console.error('‚ùå Error creando instituci√≥n:', error);
      return of({
        success: false,
        message: error.error?.message || 'Error creando instituci√≥n'
      });
    })
  );
}
  // ‚úÖ Actualizar instituci√≥n
  updateInstitution(id: number, institutionData: any): Observable<any> {
    const headers = this.getHeaders();
    
    return this.http.put(
      `${this.apiUrl}/institutions/${id}`,
      institutionData,
      { headers }
    ).pipe(
      map((response: any) => {
        console.log('üìä Respuesta actualizar instituci√≥n:', response);
        return {
          success: response.success || true,
          message: response.message || 'Instituci√≥n actualizada exitosamente'
        };
      }),
      catchError(error => {
        console.error('‚ùå Error actualizando instituci√≥n:', error);
        return of({
          success: false,
          message: error.error?.message || 'Error actualizando instituci√≥n'
        });
      })
    );
  }

  // ‚úÖ Eliminar instituci√≥n
  deleteInstitution(id: number): Observable<any> {
    const headers = this.getHeaders();
    
    return this.http.delete(
      `${this.apiUrl}/institutions/${id}`,
      { headers }
    ).pipe(
      map((response: any) => {
        console.log('üìä Respuesta eliminar instituci√≥n:', response);
        return {
          success: response.success || true,
          message: response.message || 'Instituci√≥n eliminada exitosamente'
        };
      }),
      catchError(error => {
        console.error('‚ùå Error eliminando instituci√≥n:', error);
        return of({
          success: false,
          message: error.error?.message || 'Error eliminando instituci√≥n'
        });
      })
    );
  }

  // ‚úÖ Obtener dropdown de instituciones
  getInstitutionsDropdown(): Observable<any> {
    const headers = this.getHeaders();
    
    return this.http.get(`${this.apiUrl}/institutions/dropdown`, { headers }).pipe(
      map((response: any) => {
        console.log('üìä Respuesta dropdown instituciones:', response);
        return {
          success: response.success || true,
          institutions: response.institutions || response.data || [],
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error obteniendo dropdown:', error);
        return of({
          success: false,
          message: 'Error obteniendo instituciones',
          institutions: []
        });
      })
    );
  }

  // ‚úÖ Obtener instituciones pre-registradas
  getPreRegisteredInstitutions(): Observable<any> {
    console.log('üîç Obteniendo instituciones pre-registradas...');
    
    // Datos de ejemplo para instituciones pre-registradas
    const tecsPreRegistrados = [
      {
        id: 1,
        nombre: 'Tecnol√≥gico Nacional de M√©xico - Campus Centro',
        claveCCT: 'CCT-001',
        telefono: '555-1000',
        correo: 'contacto@tecnm.mx',
        nombreRepresentante: 'Dr. Juan P√©rez',
        puestoRepresentante: 'Director General',
        direccion: 'Av. Universidad 1000, Ciudad de M√©xico',
        carreras: ['Ingenier√≠a en Sistemas', 'Administraci√≥n', 'Contadur√≠a']
      },
      {
        id: 2,
        nombre: 'Tecnol√≥gico de Estudios Superiores de Ecatepec',
        claveCCT: 'CCT-002',
        telefono: '555-2000',
        correo: 'info@tecesatepec.edu.mx',
        nombreRepresentante: 'Ing. Mar√≠a Garc√≠a',
        puestoRepresentante: 'Directora',
        direccion: 'Av. Central 200, Ecatepec, Estado de M√©xico',
        carreras: ['Ingenier√≠a Industrial', 'Ingenier√≠a en Mecatr√≥nica', 'Arquitectura']
      },
      {
        id: 3,
        nombre: 'Tecnol√≥gico de Monterrey - Campus Santa Fe',
        claveCCT: 'CCT-003',
        telefono: '555-3000',
        correo: 'admisiones@itesm.mx',
        nombreRepresentante: 'Lic. Roberto S√°nchez',
        puestoRepresentante: 'Director',
        direccion: 'Av. Carlos Lazo 100, Santa Fe, Ciudad de M√©xico',
        carreras: ['Ingenier√≠a en Tecnolog√≠as Computacionales', 'Negocios Internacionales', 'Dise√±o Industrial']
      }
    ];
    
    return of({
      success: true,
      tecs: tecsPreRegistrados,
      message: 'Instituciones pre-registradas cargadas exitosamente',
      count: tecsPreRegistrados.length
    });
  }

  // ‚úÖ Cargar instituciones pre-registradas
  loadPreRegisteredInstitutions(): Observable<any> {
    console.log('‚ö° Cargando instituciones pre-registradas...');
    
    // Simular carga de instituciones pre-registradas
    return of({
      success: true,
      message: '3 instituciones pre-registradas cargadas exitosamente',
      institutionsLoaded: 3,
      timestamp: new Date().toISOString()
    });
  }

  // ‚úÖ Descargar ejemplo Excel
  downloadExampleExcelFile(): Observable<Blob> {
    console.log('üì• Generando archivo de ejemplo Excel...');
    
    // Crear datos de ejemplo
    const exampleData = [
      ['Nombre', 'Clave CCT', 'Tel√©fono', 'Correo', 'Nombre Representante', 'Puesto Representante', 'Direcci√≥n'],
      ['Tecnol√≥gico Nacional de M√©xico', 'CCT001', '555-1000', 'contacto@tecnm.mx', 'Dr. Juan P√©rez', 'Director General', 'Av. Universidad 1000, CDMX'],
      ['TEC Campus Centro', 'CCT002', '555-2000', 'info@teccentro.edu.mx', 'Ing. Mar√≠a Garc√≠a', 'Directora', 'Calle Central 200, Centro'],
      ['TEC Campus Norte', 'CCT003', '555-3000', 'contacto@tecnorte.edu.mx', 'Lic. Roberto S√°nchez', 'Director', 'Blvd. Norte 300, Zona Industrial'],
      ['', '', '', '', '', '', ''],
      ['INSTRUCCIONES:', '', '', '', '', '', ''],
      ['1. Complete los datos en las columnas A-G', '', '', '', '', '', ''],
      ['2. No modifique los nombres de las columnas', '', '', '', '', '', ''],
      ['3. Guarde el archivo como .xlsx', '', '', '', '', '', ''],
      ['4. Cargue el archivo en el sistema', '', '', '', '', '', '']
    ];
    
    try {
      // Crear workbook y worksheet
      const worksheet = XLSX.utils.aoa_to_sheet(exampleData);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Instituciones');
      
      // Ajustar ancho de columnas
      const colWidths = [
        { wch: 30 }, // Nombre
        { wch: 12 }, // Clave CCT
        { wch: 15 }, // Tel√©fono
        { wch: 25 }, // Correo
        { wch: 25 }, // Nombre Representante
        { wch: 20 }, // Puesto Representante
        { wch: 40 }  // Direcci√≥n
      ];
      worksheet['!cols'] = colWidths;
      
      // Generar archivo Excel
      const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
      const blob = new Blob([excelBuffer], { 
        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
      });
      
      console.log('‚úÖ Archivo de ejemplo generado exitosamente');
      return of(blob);
      
    } catch (error) {
      console.error('‚ùå Error generando archivo de ejemplo:', error);
      // Retornar un blob vac√≠o en caso de error
      const emptyBlob = new Blob([''], { type: 'text/plain' });
      return of(emptyBlob);
    }
  }

  // ‚úÖ Manejar descarga de archivo
  handleDownload(blob: Blob, filename: string): void {
    try {
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      
      // Limpiar
      setTimeout(() => {
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
      }, 100);
      
      console.log(`‚úÖ Archivo "${filename}" descargado exitosamente`);
    } catch (error) {
      console.error('‚ùå Error descargando archivo:', error);
      alert('Error al descargar el archivo. Por favor, intente nuevamente.');
    }
  }

  // ‚úÖ Descargar instituciones JSON
  downloadInstitutionsJSON(): Observable<Blob> {
    const headers = this.getHeaders();
    
    return this.http.get(`${this.apiUrl}/institutions/download/json`, {
      headers,
      responseType: 'blob'
    }).pipe(
      catchError(error => {
        console.error('‚ùå Error descargando JSON:', error);
        // Retornar un blob vac√≠o en caso de error
        const emptyBlob = new Blob(['[]'], { type: 'application/json' });
        return of(emptyBlob);
      })
    );
  }

  // ‚úÖ Descargar instituciones Excel
  downloadInstitutionsExcel(): Observable<Blob> {
    const headers = this.getHeaders();
    
    return this.http.get(`${this.apiUrl}/institutions/download/excel`, {
      headers,
      responseType: 'blob'
    }).pipe(
      catchError(error => {
        console.error('‚ùå Error descargando Excel:', error);
        // Crear un Excel vac√≠o en caso de error
        const worksheet = XLSX.utils.aoa_to_sheet([['No hay datos disponibles']]);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Instituciones');
        const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([excelBuffer], { 
          type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
        });
        return of(blob);
      })
    );
  }

  // ‚úÖ Descargar datos completos JSON
  downloadCompleteDataJSON(): Observable<Blob> {
    const headers = this.getHeaders();
    
    return this.http.get(`${this.apiUrl}/institutions/complete/json`, {
      headers,
      responseType: 'blob'
    }).pipe(
      catchError(error => {
        console.error('‚ùå Error descargando datos completos JSON:', error);
        const emptyBlob = new Blob(['{"institutions": [], "careers": []}'], { 
          type: 'application/json' 
        });
        return of(emptyBlob);
      })
    );
  }

  // ‚úÖ Descargar datos completos Excel
  downloadCompleteDataExcel(): Observable<Blob> {
    const headers = this.getHeaders();
    
    return this.http.get(`${this.apiUrl}/institutions/complete/excel`, {
      headers,
      responseType: 'blob'
    }).pipe(
      catchError(error => {
        console.error('‚ùå Error descargando datos completos Excel:', error);
        const worksheet = XLSX.utils.aoa_to_sheet([['No hay datos disponibles']]);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Reporte');
        const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([excelBuffer], { 
          type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
        });
        return of(blob);
      })
    );
  }

  // ‚úÖ M√©todos para compatibilidad (mantener interfaces existentes)
  getMyInstitutionsWithUserId(userId: number): Observable<any> {
    return this.getMyInstitutions();
  }

  downloadInstitutionsJSONWithUserId(userId: number): Observable<Blob> {
    return this.downloadInstitutionsJSON();
  }

  downloadInstitutionsExcelWithUserId(userId: number): Observable<Blob> {
    return this.downloadInstitutionsExcel();
  }

  downloadInstitutionsTXTWithUserId(userId: number): Observable<Blob> {
    // Para TXT, generamos un archivo de texto simple
    const txtContent = 'Formato TXT no disponible. Use JSON o Excel.';
    const blob = new Blob([txtContent], { type: 'text/plain' });
    return of(blob);
  }

  downloadCompleteDataJSONWithUserId(userId: number): Observable<Blob> {
    return this.downloadCompleteDataJSON();
  }

  downloadCompleteDataExcelWithUserId(userId: number): Observable<Blob> {
    return this.downloadCompleteDataExcel();
  }

  // ‚úÖ Buscar instituciones
  searchInstitutions(searchTerm: string): Observable<any> {
    const headers = this.getHeaders();
    
    return this.http.get(`${this.apiUrl}/institutions/search?q=${encodeURIComponent(searchTerm)}`, { headers }).pipe(
      map((response: any) => {
        console.log('üîç Resultados de b√∫squeda:', response);
        return {
          success: response.success || true,
          institutions: response.institutions || response.data || [],
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error buscando instituciones:', error);
        return of({
          success: false,
          message: 'Error buscando instituciones',
          institutions: []
        });
      })
    );
  }

  // ‚úÖ Obtener estad√≠sticas
  getInstitutionStats(): Observable<any> {
    const headers = this.getHeaders();
    
    return this.http.get(`${this.apiUrl}/institutions/stats`, { headers }).pipe(
      map((response: any) => {
        console.log('üìä Estad√≠sticas de instituciones:', response);
        return {
          success: response.success || true,
          stats: response.stats || response.data,
          message: response.message || ''
        };
      }),
      catchError(error => {
        console.error('‚ùå Error obteniendo estad√≠sticas:', error);
        return of({
          success: false,
          message: 'Error obteniendo estad√≠sticas'
        });
      })
    );
  }
}import { Component, OnInit, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { FormsModule } from '@angular/forms';
import { Router } from '@angular/router';
import { InstitutionService } from '../../services/institution.service';
import { CareerService } from '../../services/career.service';
import { AuthService } from '../../services/auth.service';
import { Institution, InstitutionCreate } from '../../models/institution.model';
import { Career, CareerCreate, CareerMetrics, CareerStatistics, convertCareerFromBackend } from '../../models/career.model';
import { User } from '../../models/user.model';
import * as XLSX from 'xlsx';

// Importar Chart.js
import { Chart, registerables } from 'chart.js';
Chart.register(...registerables);

@Component({
  selector: 'app-dashboard',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, FormsModule],
  templateUrl: './dashboard.html',
  styleUrls: ['./dashboard.css']
})
export class DashboardComponent implements OnInit, AfterViewInit {
  // Propiedades principales
  institutions: Institution[] = [];
  careers: Career[] = [];
  institutionForm: FormGroup;
  careerForm: FormGroup;
  metricsForm: FormGroup;

  showForm = false;
  showCareerForm = false;
  editingInstitution: Institution | null = null;
  editingCareer: Career | null = null;
  editingMetricsCareer: Career | null = null;

  submitted = false;
  careerSubmitted = false;

  currentUser: User | null = null;
  carrerasDisponibles: Career[] = [];
  carrerasSeleccionadas: string[] = [];
  filtroCarreras = '';

  // Variables para la subida de archivos Excel
  isDragOver = false;
  fileUploadState: 'idle' | 'uploading' | 'success' | 'error' = 'idle';
  uploadErrorMessage = '';
  institutionsAdded = 0;
  totalInstitutionsProcessed = 0;

  // Variables para el logo
  selectedLogo: File | null = null;
  logoPreview: string | null = null;

  // Variables para logo de carrera
  careerLogoPreview: string | null = null;
  selectedCareerLogo: File | null = null;

  // Modalidades y turnos disponibles
  modalidades = ['Escolarizada', 'Mixta', 'Virtual'];
  turnos = ['Matutino', 'Vespertino', 'Nocturno', 'Mixto'];

  // Lista de tecnol√≥gicos pre-registrados
  tecnologicosPreRegistrados: any[] = [];

  // Propiedades para manejo de estado
  loadingInstitutions = false;
  loadingCareers = false;
  successMessage = '';
  errorMessage = '';
  infoMessage = '';

  // PROPIEDADES PARA GR√ÅFICAS
  private charts: any = {};
  statistics: CareerStatistics | null = null;

  // Propiedades para confirmaci√≥n de eliminaci√≥n
  itemToDelete: any = null;
  deleteType: 'institution' | 'career' | null = null;

  // Propiedades de control de acceso
  isAdminUser = false;
  canAddMultipleInstitutions = true;
  userMaxInstitutions = 1; // Usuarios normales solo pueden tener 1 instituci√≥n

  // Estad√≠sticas del dashboard
  dashboardStats = {
    totalInstitutions: 0,
    totalCareers: 0,
    institutionsAddedByUser: 0,
    lastUpdated: new Date()
  };

  constructor(
    private formBuilder: FormBuilder,
    private institutionService: InstitutionService,
    private careerService: CareerService,
    private authService: AuthService,
    private router: Router
  ) {
    // Formulario de instituci√≥n
    this.institutionForm = this.formBuilder.group({
      nombre: ['', Validators.required],
      claveCCT: ['', Validators.required],
      telefono: ['', Validators.required],
      extension: [''],
      correo: ['', [Validators.required, Validators.email]],
      nombreRepresentante: ['', Validators.required],
      puestoRepresentante: ['', Validators.required],
      direccion: ['', Validators.required],
      carreras: [[]],
      logo: ['']
    });

    // Formulario de carrera
    this.careerForm = this.formBuilder.group({
      nombre: ['', Validators.required],
      numeroCarrera: ['', Validators.required],
      cantidadAlumnos: [0, [Validators.required, Validators.min(0)]],
      duracionSemestres: [8, [Validators.required, Validators.min(1), Validators.max(12)]],
      modalidad: ['Escolarizada', Validators.required],
      turno: ['Matutino', Validators.required],
      descripcion: [''],
      activa: [true],
      poblacionEsperada: [0, [Validators.required, Validators.min(0)]],
      poblacionReal: [0, [Validators.required, Validators.min(0)]],
      logo: [''] // Campo opcional para logo de carrera
    });

    // Formulario para m√©tricas
    this.metricsForm = this.formBuilder.group({
      poblacionEsperada: [0, [Validators.required, Validators.min(0)]],
      poblacionReal: [0, [Validators.required, Validators.min(0)]]
    });
  }

  ngOnInit(): void {
    this.currentUser = this.authService.currentUserValue;
    this.isAdminUser = this.authService.isAdmin();
    
    console.log('üîç DEBUG - Usuario actual:', {
      username: this.currentUser?.username,
      email: this.currentUser?.email,
      role: this.currentUser?.role || 'user',
      isAdmin: this.isAdminUser
    });
    
    // Usuarios normales solo pueden agregar una instituci√≥n
    this.canAddMultipleInstitutions = this.isAdminUser || this.institutions.length === 0;
    
    if (this.currentUser && this.currentUser.id) {
      this.loadInstitutions();
      this.loadCareers();
      this.cargarCarrerasDisponibles();
      this.cargarListaTecnologicosPreRegistrados();
      
      // Verificar si es administrador
      if (this.isAdminUser) {
        console.log('üëë Usuario es administrador - Acceso completo');
      } else {
        console.log('üë§ Usuario normal - Acceso limitado a una instituci√≥n');
      }
    } else {
      console.error('‚ùå No hay usuario autenticado');
      this.router.navigate(['/login']);
    }
  }

  ngAfterViewInit(): void {
    // Inicializar gr√°ficas despu√©s de que la vista est√© cargada
    setTimeout(() => {
      this.initializeCharts();
    }, 1000);
  }

  // ========== M√âTODOS DE CONVERSI√ìN PARA CARRERAS ==========

  // M√©todo para convertir nombres de carrera a IDs
  private convertirNombresCarrerasAIds(nombresCarreras: string[]): number[] {
    const ids: number[] = [];
    
    console.log('üîÑ Convirtiendo nombres de carrera a IDs...');
    console.log('üìã Nombres recibidos:', nombresCarreras);
    console.log('üéì Carreras disponibles:', this.carrerasDisponibles.length);
    
    for (const nombre of nombresCarreras) {
      // Buscar en carrerasDisponibles
      const carrera = this.carrerasDisponibles.find(c => 
        c.nombre.toLowerCase() === nombre.toLowerCase()
      );
      
      if (carrera && carrera.id) {
        ids.push(carrera.id);
        console.log(`‚úÖ Convertido: "${nombre}" ‚Üí ID ${carrera.id}`);
      } else {
        console.warn(`‚ö†Ô∏è Carrera no encontrada en lista: "${nombre}"`);
        // Buscar alternativa en todas las carreras (incluyendo las del usuario)
        const carreraAlternativa = this.careers.find(c => 
          c.nombre.toLowerCase() === nombre.toLowerCase()
        );
        if (carreraAlternativa && carreraAlternativa.id) {
          ids.push(carreraAlternativa.id);
          console.log(`‚úÖ Encontrada en carreras del usuario: "${nombre}" ‚Üí ID ${carreraAlternativa.id}`);
        }
      }
    }
    
    console.log('üéì IDs resultantes:', ids);
    return ids;
  }

  // M√©todo para verificar si un string es un ID num√©rico
  private esIdNumerico(valor: any): boolean {
    return !isNaN(valor) && typeof valor !== 'boolean' && valor !== null;
  }

  // M√©todo para normalizar carreras (acepta nombres o IDs)
  private normalizarCarrerasParaEnvio(carreras: any[]): number[] {
    if (!carreras || carreras.length === 0) {
      return [];
    }
    
    const ids: number[] = [];
    
    for (const item of carreras) {
      // Si ya es un n√∫mero, usarlo directamente
      if (this.esIdNumerico(item)) {
        ids.push(Number(item));
      } 
      // Si es string, intentar convertirlo
      else if (typeof item === 'string') {
        // Primero intentar convertir directamente (por si es "1", "2", etc.)
        if (this.esIdNumerico(item)) {
          ids.push(Number(item));
        } else {
          // Buscar por nombre
          const carrera = this.carrerasDisponibles.find(c => 
            c.nombre.toLowerCase() === item.toLowerCase() ||
            c.numeroCarrera.toLowerCase() === item.toLowerCase()
          );
          
          if (carrera && carrera.id) {
            ids.push(carrera.id);
          } else {
            console.warn(`‚ö†Ô∏è No se pudo convertir: ${item}`);
          }
        }
      }
      // Si es objeto Career, extraer el ID
      else if (item && typeof item === 'object' && item.id) {
        ids.push(item.id);
      }
    }
    
    return ids;
  }

  // ========== GETTERS PARA FORMULARIOS ==========
  get f() { return this.institutionForm.controls; }
  get cf() { return this.careerForm.controls; }

  // ========== M√âTODOS DE AUTENTICACI√ìN ==========
  logout(): void {
    if (confirm('¬øEst√°s seguro de que deseas cerrar sesi√≥n?')) {
      this.authService.logout();
      this.router.navigate(['/login']);
    }
  }

  // ========== SISTEMA DE NOTIFICACIONES MEJORADO ==========
  dismissNotification(type: 'success' | 'error' | 'info'): void {
    switch (type) {
      case 'success':
        this.successMessage = '';
        break;
      case 'error':
        this.errorMessage = '';
        break;
      case 'info':
        this.infoMessage = '';
        break;
    }
  }

  showSuccess(message: string): void {
    this.successMessage = message;
    setTimeout(() => this.dismissNotification('success'), 5000);
  }

  showError(message: string): void {
    this.errorMessage = message;
    setTimeout(() => this.dismissNotification('error'), 5000);
  }

  showInfo(message: string): void {
    this.infoMessage = message;
    setTimeout(() => this.dismissNotification('info'), 5000);
  }

  // ========== M√âTODOS PARA GR√ÅFICAS ==========

  private initializeCharts(): void {
    if (this.careers.length > 0) {
      this.createComparisonChart();
      this.createMiniCharts();
    }
  }

  private createComparisonChart(): void {
    const ctx = document.getElementById('comparisonChart') as HTMLCanvasElement;
    if (!ctx) return;

    // Destruir gr√°fica existente si existe
    if (this.charts.comparison) {
      this.charts.comparison.destroy();
    }

    const labels = this.careers.map(c => c.nombre);
    const esperada = this.careers.map(c => c.poblacionEsperada || 0);
    const real = this.careers.map(c => c.poblacionReal || 0);

    this.charts.comparison = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Poblaci√≥n Esperada',
            data: esperada,
            backgroundColor: 'rgba(54, 162, 235, 0.8)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
          },
          {
            label: 'Poblaci√≥n Real',
            data: real,
            backgroundColor: 'rgba(75, 192, 192, 0.8)',
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 1
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: 'N√∫mero de Estudiantes'
            }
          },
          x: {
            title: {
              display: true,
              text: 'Carreras'
            }
          }
        },
        plugins: {
          legend: {
            position: 'top',
          },
          title: {
            display: true,
            text: 'Comparativa de Poblaci√≥n Estudiantil por Carrera'
          }
        }
      }
    });
  }

  private createMiniCharts(): void {
    this.careers.forEach(career => {
      const canvasId = `miniChart_${career.id}`;
      const ctx = document.getElementById(canvasId) as HTMLCanvasElement;
      if (!ctx) return;

      // Destruir gr√°fica existente si existe
      if (this.charts[canvasId]) {
        this.charts[canvasId].destroy();
      }

      this.charts[canvasId] = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: ['Esperado', 'Real'],
          datasets: [{
            data: [career.poblacionEsperada || 0, career.poblacionReal || 0],
            backgroundColor: [
              'rgba(54, 162, 235, 0.8)',
              'rgba(75, 192, 192, 0.8)'
            ],
            borderColor: [
              'rgba(54, 162, 235, 1)',
              'rgba(75, 192, 192, 1)'
            ],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${context.label}: ${context.parsed}`;
                }
              }
            }
          },
          cutout: '60%'
        }
      });
    });
  }

  // ========== M√âTODOS PARA M√âTRICAS ==========

  getTotalPoblacionEsperada(): number {
    return this.careers.reduce((total, career) => total + (career.poblacionEsperada || 0), 0);
  }

  getTotalPoblacionReal(): number {
    return this.careers.reduce((total, career) => total + (career.poblacionReal || 0), 0);
  }

  getPorcentajeCumplimiento(): number {
    const totalEsperado = this.getTotalPoblacionEsperada();
    const totalReal = this.getTotalPoblacionReal();
    if (totalEsperado === 0) return 0;
    return Math.round((totalReal / totalEsperado) * 100);
  }

  getCarrerasSobrecupo(): number {
    return this.careers.filter(career =>
      (career.poblacionReal || 0) > (career.poblacionEsperada || 0)
    ).length;
  }

  getPorcentajeCarrera(career: Career): number {
    const esperada = career.poblacionEsperada || 0;
    const real = career.poblacionReal || 0;
    if (esperada === 0) return 0;
    return Math.round((real / esperada) * 100);
  }

  getPreviewPorcentaje(): number {
    const esperada = this.metricsForm.get('poblacionEsperada')?.value || 0;
    const real = this.metricsForm.get('poblacionReal')?.value || 0;
    if (esperada === 0) return 0;
    return Math.round((real / esperada) * 100);
  }

  // ========== M√âTODOS PARA EDITAR M√âTRICAS ==========

  editCareerMetrics(career: Career): void {
    this.editingMetricsCareer = career;
    this.metricsForm.patchValue({
      poblacionEsperada: career.poblacionEsperada || 0,
      poblacionReal: career.poblacionReal || 0
    });

    // Abrir modal
    const modalElement = document.getElementById('metricsModal');
    if (modalElement) {
      const modal = new (window as any).bootstrap.Modal(modalElement);
      modal.show();
    }
  }

  updateCareerMetrics(): void {
    if (this.metricsForm.invalid || !this.editingMetricsCareer) {
      return;
    }

    const metricsData: CareerMetrics = {
      id: this.editingMetricsCareer.id!,
      poblacionEsperada: this.metricsForm.value.poblacionEsperada,
      poblacionReal: this.metricsForm.value.poblacionReal
    };

    this.careerService.updateCareerMetrics(metricsData.id, metricsData.poblacionEsperada, metricsData.poblacionReal).subscribe({
      next: (response: any) => {
        if (response.success) {
          this.showSuccess('M√©tricas actualizadas exitosamente');
          this.loadCareers();

          // Cerrar modal
          const modalElement = document.getElementById('metricsModal');
          if (modalElement) {
            const modal = (window as any).bootstrap.Modal.getInstance(modalElement);
            if (modal) modal.hide();
          }
        } else {
          this.showError('Error al actualizar m√©tricas: ' + response.message);
        }
      },
      error: (error) => {
        console.error('Error actualizando m√©tricas:', error);
        this.showError('Error de conexi√≥n al actualizar m√©tricas');
      }
    });
  }

  viewCareerDetails(career: Career): void {
    this.showInfo(`Vista detallada de ${career.nombre} - Funcionalidad en desarrollo`);
  }

  // ========== SCROLL SUAVE MEJORADO ==========
  private smoothScrollToElement(elementId: string): void {
    const element = document.getElementById(elementId);
    if (element) {
      element.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'start',
        inline: 'nearest'
      });
    }
  }

  // ========== CONFIRMACIONES DE ELIMINACI√ìN ==========
  confirmDeleteInstitution(institution: Institution): void {
    // Verificar permisos
    if (!this.isAdminUser && institution.user_id !== this.currentUser?.id) {
      this.showError('No tienes permiso para eliminar esta instituci√≥n');
      return;
    }
    
    this.itemToDelete = institution;
    this.deleteType = 'institution';
    
    const modalElement = document.getElementById('confirmDeleteModal');
    if (modalElement) {
      const modal = new (window as any).bootstrap.Modal(modalElement);
      modal.show();
    }
  }

  confirmDeleteCareer(career: Career): void {
    // Verificar permisos
    if (!this.isAdminUser && career.userId !== this.currentUser?.id) {
      this.showError('No tienes permiso para eliminar esta carrera');
      return;
    }
    
    this.itemToDelete = career;
    this.deleteType = 'career';
    
    const modalElement = document.getElementById('confirmDeleteModal');
    if (modalElement) {
      const modal = new (window as any).bootstrap.Modal(modalElement);
      modal.show();
    }
  }

  confirmDelete(): void {
    if (!this.itemToDelete || !this.deleteType) return;

    if (this.deleteType === 'institution') {
      this.deleteInstitution(this.itemToDelete.id!);
    } else if (this.deleteType === 'career') {
      this.deleteCareer(this.itemToDelete.id!);
    }

    // Cerrar modal
    const modalElement = document.getElementById('confirmDeleteModal');
    if (modalElement) {
      const modal = (window as any).bootstrap.Modal.getInstance(modalElement);
      if (modal) modal.hide();
    }

    this.itemToDelete = null;
    this.deleteType = null;
  }

  // ========== M√âTODOS PARA CONTADORES ==========
  getInstitutionCountClass(): string {
    if (this.loadingInstitutions) return 'text-warning';
    if (this.institutions.length > 0) return 'text-success';
    return 'text-danger';
  }

  getCareerCountClass(): string {
    if (this.loadingCareers) return 'text-warning';
    if (this.careers.length > 0) return 'text-success';
    return 'text-danger';
  }

  // ========== M√âTODOS EXISTENTES ACTUALIZADOS ==========

  cargarListaTecnologicosPreRegistrados(): void {
    this.institutionService.getPreRegisteredInstitutions().subscribe({
      next: (response) => {
        console.log('üìã Respuesta de tecnol√≥gicos:', response);
        if (response.success && response.tecs) {
          this.tecnologicosPreRegistrados = response.tecs;
          console.log('üìã Tecnol√≥gicos pre-registrados cargados:', this.tecnologicosPreRegistrados.length);
        } else {
          console.error('‚ùå Error cargando tecnol√≥gicos:', response.message);
          this.tecnologicosPreRegistrados = [];
        }
      },
      error: (error) => {
        console.error('‚ùå Error cargando tecnol√≥gicos pre-registrados:', error);
        this.tecnologicosPreRegistrados = [];
      }
    });
  }

  cargarTecnologicosPreRegistrados(): void {
    if (this.currentUser) {
      this.institutionService.loadPreRegisteredInstitutions().subscribe({
        next: (response) => {
          if (response.success) {
            console.log('Tecnol√≥gicos cargados:', response.message);
            this.showSuccess(response.message || 'Tecnol√≥gicos cargados exitosamente');
            this.loadInstitutions();
          } else {
            this.showError(response.message || 'Error al cargar los tecnol√≥gicos pre-registrados');
          }
        },
        error: (error) => {
          console.error('Error cargando tecnol√≥gicos:', error);
          this.showError('Error de conexi√≥n al cargar tecnol√≥gicos pre-registrados');
        }
      });
    }
  }

  // ========== M√âTODO CARGAR CARRERAS DISPONIBLES CORREGIDO ==========
  cargarCarrerasDisponibles(): void {
    console.log('üéì Cargando carreras disponibles...');
    
    this.careerService.getAvailableCareers().subscribe({
      next: (response) => {
        console.log('üéì Respuesta completa de carreras disponibles:', response);
        
        if (response.success && (response.data || response.careers)) {
          const carrerasData = response.data || response.careers;
          
          // Convertir a objetos Career
          this.carrerasDisponibles = carrerasData.map((c: any) => {
            return {
              id: c.id,
              nombre: c.nombre,
              numeroCarrera: c.numero_carrera || c.numeroCarrera,
              cantidadAlumnos: c.cantidad_alumnos || c.cantidadAlumnos || 0,
              duracionSemestres: c.duracion_semestres || c.duracionSemestres || 8,
              modalidad: c.modalidad,
              turno: c.turno,
              descripcion: c.descripcion || '',
              activa: c.activa || c.activa === 1,
              poblacionEsperada: c.poblacion_esperada || c.poblacionEsperada || 0,
              poblacionReal: c.poblacion_real || c.poblacionReal || 0,
              logo: c.logo || '',
              createdAt: c.created_at || c.createdAt,
              userId: c.user_id || c.userId
            };
          });
          
          console.log('‚úÖ Carreras disponibles cargadas:', this.carrerasDisponibles.length);
          console.log('üìã Lista completa:', this.carrerasDisponibles.map(c => ({
            id: c.id,
            nombre: c.nombre,
            esperada: c.poblacionEsperada,
            real: c.poblacionReal
          })));
          
        } else {
          console.error('‚ùå Error en respuesta de carreras disponibles:', response.message);
          this.carrerasDisponibles = [];
          this.showError(response.message || 'Error al cargar carreras disponibles');
        }
      },
      error: (error) => {
        console.error('‚ùå Error HTTP cargando carreras disponibles:', error);
        this.carrerasDisponibles = [];
        this.showError('Error de conexi√≥n al cargar carreras disponibles');
      }
    });
  }

  // ========== CARGA DE INSTITUCIONES CORREGIDA ==========
  loadInstitutions(): void {
    this.loadingInstitutions = true;
    console.log('üîÑ Cargando instituciones...');
    console.log('üë§ Usuario:', this.currentUser?.username);
    console.log('üëë Es admin?', this.isAdminUser);

    let apiCall;
    
    if (this.isAdminUser) {
      console.log('üëë Usando getAllInstitutions (admin)');
      apiCall = this.institutionService.getAllInstitutions();
    } else {
      console.log('üë§ Usando getMyInstitutions (user)');
      apiCall = this.institutionService.getMyInstitutions();
    }

    apiCall.subscribe({
      next: (response) => {
        this.loadingInstitutions = false;
        console.log('üìä Respuesta completa de instituciones:', response);
        
        if (response.success && response.institutions) {
          this.institutions = response.institutions;
          console.log('‚úÖ Instituciones cargadas:', this.institutions.length);
          if (this.institutions.length > 0) {
            console.log('üìã Primera instituci√≥n:', this.institutions[0]);
          }
        } else {
          console.error('‚ùå Error en respuesta:', response.message);
          this.showError(response.message || 'Error al cargar instituciones');
        }
      },
      error: (error) => {
        this.loadingInstitutions = false;
        console.error('‚ùå Error HTTP cargando instituciones:', error);
        
        if (error.status === 401) {
          this.showError('Sesi√≥n expirada. Por favor, inicia sesi√≥n nuevamente.');
          this.authService.logout();
          this.router.navigate(['/login']);
        } else {
          this.showError('Error de conexi√≥n al cargar instituciones');
        }
      }
    });
  }

  // ========== CARRERAS ACTUALIZADAS ==========
  loadCareers(): void {
    this.loadingCareers = true;
    console.log('üîÑ Cargando carreras...');

    this.careerService.getMyCareers().subscribe({
      next: (response) => {
        this.loadingCareers = false;
        console.log('üéì Respuesta de carreras:', response);
        if (response.success && response.data) {
          this.careers = response.data.map((c: any) => {
            const career = convertCareerFromBackend(c);
            // Log para verificar m√©tricas
            console.log(`üìä Carrera ${career.nombre}:`, {
              id: career.id,
              esperada: career.poblacionEsperada,
              real: career.poblacionReal
            });
            return career;
          });
          
          this.dashboardStats.totalCareers = this.careers.length;
          
          console.log('‚úÖ Carreras cargadas desde BD:', this.careers.length);
          console.log('üìä Resumen de m√©tricas:');
          this.careers.forEach(c => {
            console.log(`   - ${c.nombre}: Esperada=${c.poblacionEsperada}, Real=${c.poblacionReal}`);
          });

          // Inicializar gr√°ficas despu√©s de cargar carreras
          setTimeout(() => {
            this.initializeCharts();
          }, 500);
        } else {
          console.error('‚ùå Error al cargar carreras:', response.message);
          this.showError(response.message || 'Error al cargar carreras');
          this.careers = [];
        }
      },
      error: (error) => {
        this.loadingCareers = false;
        console.error('‚ùå Error cargando carreras:', error);
        this.showError('Error de conexi√≥n al cargar carreras');
        this.careers = [];
      }
    });
  }

  // ========== M√âTODO REQUERIDO POR EL PROFESOR ==========
  public agregarInstitucion(nuevaInstitucion: Institution): void {
    this.institutions.push(nuevaInstitucion);
    this.dashboardStats.totalInstitutions++;
    this.dashboardStats.institutionsAddedByUser++;
    console.log('üè´ Instituci√≥n agregada. Total de instituciones:', this.institutions.length);
  }

  // ========== M√âTODO PARA VERIFICAR CCT √öNICO ==========
  verificarCCTUnico(claveCCT: string): boolean {
    if (!claveCCT) return true;

    if (this.editingInstitution) {
      return !this.institutions.some(inst =>
        inst.clave_cct === claveCCT && inst.id !== this.editingInstitution?.id
      );
    }

    return !this.institutions.some(inst => inst.clave_cct === claveCCT);
  }

  // ========== M√âTODO DE DIAGN√ìSTICO ==========
  debugInstitutions(): void {
    console.log('=== üêõ DEBUG INSTITUCIONES ===');
    console.log('üë§ Usuario actual:', this.currentUser);
    console.log('üé≠ Es administrador:', this.isAdminUser);
    console.log('üì¶ Array institutions:', this.institutions);
    console.log('üî¢ Length:', this.institutions.length);
    console.log('üîÑ Loading state:', this.loadingInstitutions);
    console.log('=== FIN DEBUG ===');

    // Forzar recarga
    this.loadInstitutions();
  }

  // ========== M√âTODOS PARA CARRERAS EN INSTITUCIONES ==========
  toggleCarrera(carreraNombre: string): void {
    console.log('üéì Toggle carrera llamado con:', carreraNombre);
    
    const carrera = this.carrerasDisponibles.find(c => c.nombre === carreraNombre);
    if (!carrera) {
      console.error('‚ùå Carrera no encontrada:', carreraNombre);
      return;
    }
    
    console.log('üìä Informaci√≥n de carrera:', {
      id: carrera.id,
      nombre: carrera.nombre,
      poblacionEsperada: carrera.poblacionEsperada,
      poblacionReal: carrera.poblacionReal
    });
    
    const index = this.carrerasSeleccionadas.indexOf(carreraNombre);
    
    if (index > -1) {
      this.carrerasSeleccionadas.splice(index, 1);
      console.log(`‚ûñ Carrera removida: ${carreraNombre} (ID: ${carrera.id})`);
    } else {
      this.carrerasSeleccionadas.push(carreraNombre);
      console.log(`‚ûï Carrera agregada: ${carreraNombre} (ID: ${carrera.id})`);
    }
    
    this.institutionForm.patchValue({ carreras: this.carrerasSeleccionadas });
    
    console.log('üìã Carreras seleccionadas actuales:', this.carrerasSeleccionadas);
  }

  filtrarCarreras(): void {
    if (this.filtroCarreras) {
      this.carrerasDisponibles = this.carrerasDisponibles.filter(c => 
        c.nombre.toLowerCase().includes(this.filtroCarreras.toLowerCase())
      );
    } else {
      this.cargarCarrerasDisponibles();
    }
  }

  agregarNuevaCarrera(): void {
    const nuevaCarrera = this.filtroCarreras.trim();
    if (nuevaCarrera && !this.carrerasDisponibles.some(c => c.nombre === nuevaCarrera)) {
      
      // Pedir al usuario las m√©tricas iniciales
      const poblacionEsperada = prompt(`Ingrese la poblaci√≥n esperada para "${nuevaCarrera}":`, '100');
      const poblacionReal = prompt(`Ingrese la poblaci√≥n real actual para "${nuevaCarrera}":`, '50');
      
      const careerData: CareerCreate = {
        nombre: nuevaCarrera,
        numeroCarrera: this.generarNumeroCarrera(nuevaCarrera),
        cantidadAlumnos: 0,
        duracionSemestres: 8,
        modalidad: 'Escolarizada',
        turno: 'Matutino',
        descripcion: '',
        activa: true,
        poblacionEsperada: parseInt(poblacionEsperada || '100') || 100,
        poblacionReal: parseInt(poblacionReal || '50') || 50,
        logo: ''
      };

      console.log('üÜï Creando nueva carrera con m√©tricas:', careerData);

      this.careerService.createCareer(careerData).subscribe({
        next: (response) => {
          if (response.success) {
            this.showSuccess('Carrera agregada exitosamente');
            this.loadCareers(); // Recargar para ver m√©tricas
            this.cargarCarrerasDisponibles();
            this.carrerasSeleccionadas.push(nuevaCarrera);
            this.institutionForm.patchValue({ carreras: this.carrerasSeleccionadas });
            this.filtroCarreras = '';
          } else {
            this.showError('Error al agregar carrera: ' + response.message);
          }
        },
        error: (error) => {
          console.error('Error agregando carrera:', error);
          this.showError('Error de conexi√≥n al agregar la carrera');
        }
      });
    } else if (nuevaCarrera) {
      // Si la carrera ya existe, simplemente seleccionarla
      this.carrerasSeleccionadas.push(nuevaCarrera);
      this.institutionForm.patchValue({ carreras: this.carrerasSeleccionadas });
      this.showInfo(`Carrera "${nuevaCarrera}" ya existe y ha sido seleccionada`);
      this.filtroCarreras = '';
    }
  }

  private generarNumeroCarrera(nombreCarrera: string): string {
    const prefix = nombreCarrera.substring(0, 3).toUpperCase();
    const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
    return `${prefix}-${random}`;
  }

  // ========== M√âTODOS PARA GESTI√ìN DE CARRERAS ==========
  addCareer(): void {
    this.editingCareer = null;
    this.careerForm.reset({
      cantidadAlumnos: 0,
      duracionSemestres: 8,
      modalidad: 'Escolarizada',
      turno: 'Matutino',
      activa: true,
      poblacionEsperada: 100, // Valor por defecto distinto de 0
      poblacionReal: 50,      // Valor por defecto distinto de 0
      logo: ''
    });
    this.careerSubmitted = false;
    this.showCareerForm = true;
    this.careerLogoPreview = null;
    this.selectedCareerLogo = null;
    
    // Scroll suave al formulario
    setTimeout(() => {
      this.smoothScrollToElement('career-form-container');
    }, 100);
  }

  editCareer(career: Career): void {
    this.editingCareer = career;
    this.careerForm.patchValue({
      nombre: career.nombre,
      numeroCarrera: career.numeroCarrera,
      cantidadAlumnos: career.cantidadAlumnos,
      duracionSemestres: career.duracionSemestres,
      modalidad: career.modalidad,
      turno: career.turno,
      descripcion: career.descripcion,
      activa: career.activa,
      poblacionEsperada: career.poblacionEsperada || 100, // Si es 0, usar 100
      poblacionReal: career.poblacionReal || 50,          // Si es 0, usar 50
      logo: career.logo || ''
    });
    
    // Cargar logo si existe
    if (career.logo) {
      this.careerLogoPreview = career.logo;
    }
    
    this.showCareerForm = true;
    
    // Scroll suave al formulario
    setTimeout(() => {
      this.smoothScrollToElement('career-form-container');
    }, 100);
  }

  onSubmitCareer(): void {
    this.careerSubmitted = true;

    if (this.careerForm.invalid) {
      Object.keys(this.cf).forEach(key => {
        const control = this.cf[key];
        if (control.invalid) {
          control.markAsTouched();
        }
      });
      return;
    }

    const careerData: CareerCreate = {
      ...this.careerForm.value,
      logo: this.careerLogoPreview || ''
    };

    // Asegurar que las m√©tricas no sean 0
    if (careerData.poblacionEsperada === 0) {
      careerData.poblacionEsperada = 100;
    }
    if (careerData.poblacionReal === 0) {
      careerData.poblacionReal = 50;
    }

    console.log('üì§ Enviando datos de carrera:', careerData);

    if (this.editingCareer) {
      this.careerService.updateCareer(this.editingCareer.id!, careerData).subscribe({
        next: (response) => {
          if (response.success) {
            this.showSuccess('Carrera actualizada exitosamente');
            this.resetCareerForm();
            this.loadCareers();
            this.cargarCarrerasDisponibles();
          } else {
            this.showError('Error al actualizar carrera: ' + response.message);
          }
        },
        error: (error) => {
          console.error('Error actualizando carrera:', error);
          this.showError('Error de conexi√≥n al actualizar la carrera');
        }
      });
    } else {
      this.careerService.createCareer(careerData).subscribe({
        next: (response) => {
          if (response.success) {
            this.showSuccess('Carrera creada exitosamente');
            this.resetCareerForm();
            this.loadCareers();
            this.cargarCarrerasDisponibles();
          } else {
            this.showError('Error al agregar carrera: ' + response.message);
          }
        },
        error: (error) => {
          console.error('Error agregando carrera:', error);
          this.showError('Error de conexi√≥n al agregar la carrera');
        }
      });
    }
  }

  deleteCareer(id: number): void {
    this.careerService.deleteCareer(id).subscribe({
      next: (response) => {
        if (response.success) {
          this.showSuccess('Carrera eliminada exitosamente');
          this.loadCareers();
          this.cargarCarrerasDisponibles();
        } else {
          this.showError('Error al eliminar carrera: ' + response.message);
        }
      },
      error: (error) => {
        console.error('Error eliminando carrera:', error);
        this.showError('Error de conexi√≥n al eliminar la carrera');
      }
    });
  }

  cancelCareerEdit(): void {
    this.resetCareerForm();
  }

  private resetCareerForm(): void {
    this.showCareerForm = false;
    this.editingCareer = null;
    this.careerSubmitted = false;
    this.careerLogoPreview = null;
    this.selectedCareerLogo = null;
    this.careerForm.reset({
      cantidadAlumnos: 0,
      duracionSemestres: 8,
      modalidad: 'Escolarizada',
      turno: 'Matutino',
      activa: true,
      poblacionEsperada: 100,
      poblacionReal: 50,
      logo: ''
    });
  }

  // ========== M√âTODOS PARA LOGO DE INSTITUCI√ìN ==========
  onLogoSelected(event: any): void {
    const file = event.target.files[0];
    if (file) {
      const validTypes = ['image/jpeg', 'image/png', 'image/gif'];
      if (!validTypes.includes(file.type)) {
        this.showError('Por favor, selecciona una imagen v√°lida (JPG, PNG, GIF)');
        return;
      }

      if (file.size > 2 * 1024 * 1024) {
        this.showError('La imagen es demasiado grande. M√°ximo 2MB permitido.');
        return;
      }

      this.selectedLogo = file;

      const reader = new FileReader();
      reader.onload = (e: any) => {
        this.logoPreview = e.target.result;
        this.institutionForm.patchValue({ logo: this.logoPreview });
      };
      reader.readAsDataURL(file);
    }
  }

  eliminarLogo(): void {
    this.selectedLogo = null;
    this.logoPreview = null;
    this.institutionForm.patchValue({ logo: '' });
  }

  // ========== M√âTODOS PARA LOGO DE CARRERA ==========
  onCareerLogoSelected(event: any): void {
    const file = event.target.files[0];
    if (file) {
      const validTypes = ['image/jpeg', 'image/png', 'image/gif'];
      if (!validTypes.includes(file.type)) {
        this.showError('Por favor, selecciona una imagen v√°lida (JPG, PNG, GIF)');
        return;
      }

      if (file.size > 2 * 1024 * 1024) {
        this.showError('La imagen es demasiado grande. M√°ximo 2MB permitido.');
        return;
      }

      this.selectedCareerLogo = file;

      const reader = new FileReader();
      reader.onload = (e: any) => {
        this.careerLogoPreview = e.target.result;
        this.careerForm.patchValue({ logo: this.careerLogoPreview });
      };
      reader.readAsDataURL(file);
    }
  }

  eliminarCareerLogo(): void {
    this.selectedCareerLogo = null;
    this.careerLogoPreview = null;
    this.careerForm.patchValue({ logo: '' });
  }

  // ========== M√âTODOS PARA SUBIDA DE ARCHIVOS EXCEL ==========
  onFileSelected(event: any): void {
    const file = event.target.files[0];
    if (file) {
      this.processExcelFile(file);
    }
    event.target.value = '';
  }

  onFileDrop(event: DragEvent): void {
    event.preventDefault();
    this.isDragOver = false;

    const files = event.dataTransfer?.files;
    if (files && files.length > 0) {
      const file = files[0];
      this.processExcelFile(file);
    }
  }

  onDragOver(event: DragEvent): void {
    event.preventDefault();
    this.isDragOver = true;
  }

  onDragLeave(event: DragEvent): void {
    event.preventDefault();
    this.isDragOver = false;
  }

  private processExcelFile(file: File): void {
    const validTypes = [
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/vnd.ms-excel'
    ];

    const validExtensions = ['.xlsx', '.xls'];
    const fileExtension = '.' + file.name.split('.').pop()?.toLowerCase();

    if (!validTypes.includes(file.type) && !validExtensions.includes(fileExtension || '')) {
      this.showUploadError('Por favor, selecciona un archivo Excel v√°lido (.xlsx o .xls)');
      return;
    }

    if (file.size > 5 * 1024 * 1024) {
      this.showUploadError('El archivo es demasiado grande. M√°ximo 5MB permitido.');
      return;
    }

    this.fileUploadState = 'uploading';
    this.uploadErrorMessage = '';

    const reader = new FileReader();

    reader.onload = (e: any) => {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });

        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

        this.processExcelData(jsonData);

      } catch (error) {
        console.error('Error al procesar Excel:', error);
        this.showUploadError('Error al procesar el archivo Excel. Verifica el formato.');
      }
    };

    reader.onerror = () => {
      this.showUploadError('Error al leer el archivo.');
    };

    reader.readAsArrayBuffer(file);
  }

  private processExcelData(excelData: any[]): void {
    if (!excelData || excelData.length < 2) {
      this.showUploadError('El archivo Excel est√° vac√≠o o no tiene datos v√°lidos.');
      return;
    }

    const headers = excelData[0].map((header: string) =>
      header ? header.toString().toLowerCase().trim() : ''
    );

    const nombreIndex = this.findColumnIndex(headers, ['nombre', 'instituci√≥n', 'institucion']);
    const claveCCTIndex = this.findColumnIndex(headers, ['clave cct', 'cct', 'clave']);
    const telefonoIndex = this.findColumnIndex(headers, ['tel√©fono', 'telefono', 'phone']);
    const extensionIndex = this.findColumnIndex(headers, ['extensi√≥n', 'extension', 'ext']);
    const correoIndex = this.findColumnIndex(headers, ['correo', 'email', 'e-mail']);
    const nombreRepresentanteIndex = this.findColumnIndex(headers, ['representante', 'nombre representante', 'contacto']);
    const puestoRepresentanteIndex = this.findColumnIndex(headers, ['puesto', 'cargo', 'puesto representante']);
    const direccionIndex = this.findColumnIndex(headers, ['direcci√≥n', 'direccion', 'address']);

    if (nombreIndex === -1 || claveCCTIndex === -1) {
      this.showUploadError('El archivo debe contener al menos las columnas "Nombre" y "Clave CCT".');
      return;
    }

    const institutionsData: InstitutionCreate[] = [];

    for (let i = 1; i < excelData.length; i++) {
      const row = excelData[i];
      if (!row || row.length === 0) continue;

      const institution: InstitutionCreate = {
        nombre: row[nombreIndex]?.toString().trim() || '',
        claveCCT: row[claveCCTIndex]?.toString().trim() || '',
        telefono: telefonoIndex !== -1 ? (row[telefonoIndex]?.toString().trim() || '') : 'No especificado',
        extension: extensionIndex !== -1 ? (row[extensionIndex]?.toString().trim() || '') : '',
        correo: correoIndex !== -1 ? (row[correoIndex]?.toString().trim() || '') : 'no@especificado.edu.mx',
        nombreRepresentante: nombreRepresentanteIndex !== -1 ? (row[nombreRepresentanteIndex]?.toString().trim() || '') : 'No especificado',
        puestoRepresentante: puestoRepresentanteIndex !== -1 ? (row[puestoRepresentanteIndex]?.toString().trim() || '') : 'No especificado',
        direccion: direccionIndex !== -1 ? (row[direccionIndex]?.toString().trim() || '') : 'No especificado',
        carreras: []
      };

      if (institution.nombre && institution.claveCCT) {
        institutionsData.push(institution);
      }
    }

    if (institutionsData.length === 0) {
      this.showUploadError('No se encontraron datos v√°lidos en el archivo Excel.');
      return;
    }

    this.totalInstitutionsProcessed = institutionsData.length;
    this.addInstitutionsFromExcel(institutionsData);
  }

  private findColumnIndex(headers: string[], possibleNames: string[]): number {
    for (const name of possibleNames) {
      const index = headers.findIndex(header =>
        header.includes(name) || name.includes(header)
      );
      if (index !== -1) return index;
    }
    return -1;
  }

  private addInstitutionsFromExcel(institutionsData: InstitutionCreate[]): void {
    let addedCount = 0;
    let processedCount = 0;

    institutionsData.forEach(institutionData => {
      // Convertir nombres de carrera vac√≠os a IDs
      const carreraIds = this.normalizarCarrerasParaEnvio([]);
      institutionData.carreras = carreraIds;
      
      this.institutionService.createInstitution(institutionData)
        .subscribe({
          next: (response) => {
            if (response.success && response.institution) {
              // Normalizar la instituci√≥n que devuelve el backend
              this.agregarInstitucion(this.mapInstitution(response.institution));
              addedCount++;
            } else {
              console.error('Error agregando instituci√≥n desde Excel:', response.message);
            }
            processedCount++;

            if (processedCount === institutionsData.length) {
              this.finishUpload(addedCount);
            }
          },
          error: (error) => {
            console.error('Error agregando instituci√≥n desde Excel:', error);
            processedCount++;

            if (processedCount === institutionsData.length) {
              this.finishUpload(addedCount);
            }
          }
        });
    });
  }

  private finishUpload(addedCount: number): void {
    this.institutionsAdded = addedCount;
    this.fileUploadState = 'success';
    this.loadInstitutions();

    setTimeout(() => {
      this.fileUploadState = 'idle';
    }, 8000);
  }

  private showUploadError(message: string): void {
    this.uploadErrorMessage = message;
    this.fileUploadState = 'error';

    setTimeout(() => {
      this.fileUploadState = 'idle';
    }, 5000);
  }

  // ========== M√âTODOS DEL FORMULARIO DE INSTITUCIONES ==========
  addInstitution(): void {
    // Verificar si el usuario normal ya tiene una instituci√≥n
    if (!this.isAdminUser && this.institutions.length >= this.userMaxInstitutions) {
      this.showError('Los usuarios normales solo pueden registrar una instituci√≥n. Contacte al administrador para m√°s informaci√≥n.');
      return;
    }
    
    this.editingInstitution = null;
    this.institutionForm.reset();
    this.carrerasSeleccionadas = [];
    this.logoPreview = null;
    this.selectedLogo = null;
    this.submitted = false;
    this.showForm = true;
    this.filtroCarreras = '';
    this.cargarCarrerasDisponibles();
    
    // Scroll suave al formulario
    setTimeout(() => {
      this.smoothScrollToElement('institution-form-container');
    }, 100);
  }

  editInstitution(institution: Institution): void {
    // Verificar permisos
    if (!this.isAdminUser && institution.user_id !== this.currentUser?.id) {
      this.showError('No tienes permiso para editar esta instituci√≥n');
      return;
    }
    
    this.editingInstitution = institution;
    this.institutionForm.patchValue(institution);
    this.carrerasSeleccionadas = institution.carreras || [];
    this.logoPreview = institution.logo || null;
    this.showForm = true;
    
    // Scroll suave al formulario
    setTimeout(() => {
      this.smoothScrollToElement('institution-form-container');
    }, 100);
  }

  deleteInstitution(id: number): void {
    this.institutionService.deleteInstitution(id)
      .subscribe({
        next: (response) => {
          if (response.success) {
            this.showSuccess('Instituci√≥n eliminada exitosamente');
            this.loadInstitutions();
            this.dashboardStats.totalInstitutions--;
          } else {
            this.showError(response.message || 'Error al eliminar instituci√≥n');
          }
        },
        error: (error) => {
          console.error('Error eliminando instituci√≥n:', error);
          this.showError('Error de conexi√≥n al eliminar la instituci√≥n');
        }
      });
  }

  // ========== M√âTODO onSubmit() CORREGIDO ==========
  onSubmit(): void {
    console.log('üîç DEBUG - Estado actual:');
    console.log('   - Usuario ID:', this.currentUser?.id);
    console.log('   - Instituci√≥n en edici√≥n:', this.editingInstitution);
    console.log('   - ID de instituci√≥n en edici√≥n:', this.editingInstitution?.id);
    console.log('   - ¬øEs una instituci√≥n nueva?', !this.editingInstitution);
    console.log('   - Total de instituciones del usuario:', this.institutions.length);
    console.log('   - IDs de instituciones:', this.institutions.map(i => i.id));
    console.log('   - Carreras seleccionadas (nombres):', this.carrerasSeleccionadas); 
    this.submitted = true;

    if (this.institutionForm.invalid) {
      Object.keys(this.f).forEach(key => {
        const control = this.f[key];
        if (control.invalid) {
          control.markAsTouched();
        }
      });
      return;
    }

    if (this.carrerasSeleccionadas.length === 0) {
      this.showError('Debe seleccionar al menos una carrera');
      return;
    }

    const claveCCT = this.institutionForm.get('claveCCT')?.value;

    if (!this.editingInstitution && !this.verificarCCTUnico(claveCCT)) {
      this.showError('Ya existe una instituci√≥n con esta Clave CCT. Por favor, use una clave √∫nica.');
      return;
    }

    // ‚úÖ CONVERTIR NOMBRES A IDs ANTES DE ENVIAR
    console.log('üîç ANTES de conversi√≥n - carrerasSeleccionadas:', this.carrerasSeleccionadas);
    
    // Convertir nombres de carrera a IDs
    const carreraIds = this.carrerasSeleccionadas.map(nombre => {
      const carrera = this.carrerasDisponibles.find(c => 
        c.nombre.toLowerCase() === nombre.toLowerCase()
      );
      return carrera?.id;
    }).filter(id => id !== undefined) as number[];
    
    console.log('üîç DESPU√âS de conversi√≥n - carreraIds:', carreraIds);
    
    if (carreraIds.length === 0) {
      this.showError('No se pudieron encontrar IDs v√°lidos para las carreras seleccionadas. Aseg√∫rese de que las carreras est√©n cargadas en el sistema.');
      return;
    }

    const institutionData: InstitutionCreate = {
      nombre: this.institutionForm.get('nombre')?.value,
      claveCCT: this.institutionForm.get('claveCCT')?.value,
      telefono: this.institutionForm.get('telefono')?.value,
      extension: this.institutionForm.get('extension')?.value || '',
      correo: this.institutionForm.get('correo')?.value,
      nombreRepresentante: this.institutionForm.get('nombreRepresentante')?.value,
      puestoRepresentante: this.institutionForm.get('puestoRepresentante')?.value,
      direccion: this.institutionForm.get('direccion')?.value,
      carreras: carreraIds, // ‚Üê IDs num√©ricos, no nombres
      logo: this.logoPreview || '',
      estado: 'active'
    };

    console.log('üì§ Datos listos para enviar:', institutionData);
    console.log('üéì IDs de carrera que se enviar√°n:', carreraIds);

    if (this.editingInstitution) {
      console.log('‚úèÔ∏è Actualizando instituci√≥n existente...');
      this.institutionService.updateInstitution(this.editingInstitution.id!, institutionData)
        .subscribe({
          next: (response) => {
            console.log('üì© Respuesta del servidor (update):', response);
            if (response.success) {
              this.showSuccess('Instituci√≥n actualizada exitosamente');
              this.resetForm();
              this.loadInstitutions();
            } else {
              this.showError(response.message || 'Error al actualizar instituci√≥n');
            }
          },
          error: (error) => {
            console.error('‚ùå Error actualizando instituci√≥n:', error);
            if (error.error) {
              console.error('‚ùå Detalles del error:', error.error);
            }
            this.showError('Error de conexi√≥n al actualizar la instituci√≥n: ' + (error.error?.message || error.message));
          }
        });
    } else {
      console.log('üÜï Creando nueva instituci√≥n...');
      this.institutionService.createInstitution(institutionData)
        .subscribe({
          next: (response) => {
            console.log('üì© Respuesta del servidor (create):', response);
            if (response.success && response.data) {
              const institucionMapeada = this.mapInstitution(response.data);
              this.agregarInstitucion(institucionMapeada);
              this.showSuccess('Instituci√≥n creada exitosamente');
              this.resetForm();
              this.loadInstitutions();
            } else {
              this.showError(response.message || 'Error al crear instituci√≥n');
            }
          },
          error: (error) => {
            console.error('‚ùå Error creando instituci√≥n:', error);
            if (error.error) {
              console.error('‚ùå Detalles del error:', error.error);
              console.error('‚ùå Stack trace:', error.error.stack);
            }
            this.showError('Error de conexi√≥n al crear la instituci√≥n: ' + (error.error?.message || error.message));
          }
        });
    }
  }

  // =================== MAPEO / NORMALIZACI√ìN DE DATOS ===================
  // Convierte una instituci√≥n del backend a un objeto manejable en frontend
  private mapInstitution(inst: any): any {
    if (!inst) return inst;

    const carreras = Array.isArray(inst.carreras) ? inst.carreras.map((c: any) => {
      if (typeof c === 'string') return c;
      if (c.nombre) return c.nombre;
      if (c.numero_carrera) return c.numero_carrera;
      if (c.numeroCarrera) return c.numeroCarrera;
      return c;
    }) : [];

    return {
      id: inst.id,
      userId: inst.user_id,
      nombre: inst.nombre,
      clave_cct: inst.clave_cct,
      telefono: inst.telefono,
      extension: inst.extension,
      correo: inst.correo,
      nombre_representante: inst.nombre_representante,
      puesto_representante: inst.puesto_representante,
      direccion: inst.direccion,
      logo: inst.logo,
      carreras: carreras,
      estado: inst.estado,
      created_at: inst.created_at,
      propietario: inst.propietario
    };
  }

  cancelEdit(): void {
    this.resetForm();
  }

  private resetForm(): void {
    this.showForm = false;
    this.editingInstitution = null;
    this.submitted = false;
    this.institutionForm.reset();
    this.carrerasSeleccionadas = [];
    this.logoPreview = null;
    this.selectedLogo = null;
    this.filtroCarreras = '';
    this.cargarCarrerasDisponibles();
  }

  // ========== M√âTODO PARA CARGAR TECNOL√ìGICO R√ÅPIDO ==========
  cargarTecnologicoRapido(tecnologico: any): void {
    // Verificar si el usuario normal ya tiene una instituci√≥n
    if (!this.isAdminUser && this.institutions.length >= this.userMaxInstitutions) {
      this.showError('Los usuarios normales solo pueden registrar una instituci√≥n');
      return;
    }
    
    this.institutionForm.patchValue(tecnologico);
    this.carrerasSeleccionadas = tecnologico.carreras || [];
    this.showForm = true;
    this.editingInstitution = null;
    this.submitted = false;
    
    // Scroll suave al formulario
    setTimeout(() => {
      this.smoothScrollToElement('institution-form-container');
    }, 100);
  }

  // ========== M√âTODO AUXILIAR PARA OBTENER CIUDAD ==========
  getCiudadFromDireccion(direccion: string): string {
    const partes = direccion.split(',');
    return partes.length >= 3 ? partes[2].trim() : direccion;
  }

  // ========== M√âTODO TEMPORAL PARA CREAR INSTITUCI√ìN DE PRUEBA ==========
  createTestInstitution(): void {
    // Primero cargar carreras si no est√°n disponibles
    if (this.carrerasDisponibles.length === 0) {
      this.cargarCarrerasDisponibles();
      this.showInfo('Cargando carreras disponibles primero...');
      setTimeout(() => {
        this.createTestInstitution();
      }, 1000);
      return;
    }

    // Obtener IDs de ejemplo de las primeras 2 carreras disponibles
    const carreraIds = this.carrerasDisponibles.slice(0, 2).map(c => c.id);
    
    if (carreraIds.length === 0) {
      this.showError('No hay carreras disponibles para crear instituci√≥n de prueba');
      return;
    }

    const testInstitution = {
      nombre: 'Tecnol√≥gico de Prueba - ' + new Date().toLocaleTimeString(),
      claveCCT: 'CCT' + Date.now(),
      telefono: '555-1234',
      correo: 'tecnologico@ejemplo.com',
      nombreRepresentante: 'Director de Prueba',
      puestoRepresentante: 'Director',
      direccion: 'Av. Universidad 123',
      carreras: carreraIds, // ‚Üê IDs num√©ricos
      estado: 'active'
    };

    console.log('üÜï Creando instituci√≥n de prueba con IDs:', carreraIds);

    this.institutionService.createInstitution(testInstitution).subscribe(
      response => {
        console.log('‚úÖ Respuesta creaci√≥n:', response);
        if (response.success) {
          this.showSuccess('‚úÖ Instituci√≥n creada exitosamente');
          this.loadInstitutions();
        } else {
          this.showError('‚ùå Error: ' + response.message);
        }
      },
      error => {
        console.error('‚ùå Error:', error);
        this.showError('Error de conexi√≥n: ' + (error.error?.message || error.message));
      }
    );
  }

  // ========== M√âTODO PARA DEPURACI√ìN ==========
  debugCarreras(): void {
    console.log('=== üêõ DEBUG CARRERAS ===');
    console.log('üéì Carreras disponibles:', this.carrerasDisponibles.length);
    this.carrerasDisponibles.forEach((c, i) => {
      console.log(`   ${i + 1}. ID: ${c.id}, Nombre: "${c.nombre}", N√∫mero: ${c.numeroCarrera}`);
      console.log(`      Poblaci√≥n Esperada: ${c.poblacionEsperada}, Real: ${c.poblacionReal}`);
    });
    
    console.log('üìã Carreras seleccionadas:', this.carrerasSeleccionadas);
    
    const idsConvertidos = this.normalizarCarrerasParaEnvio(this.carrerasSeleccionadas);
    console.log('üîÑ IDs convertidos:', idsConvertidos);
    
    console.log('üéì Carreras del usuario:', this.careers.length);
    this.careers.forEach((c, i) => {
      console.log(`   ${i + 1}. ID: ${c.id}, Nombre: "${c.nombre}"`);
      console.log(`      Poblaci√≥n Esperada: ${c.poblacionEsperada}, Real: ${c.poblacionReal}`);
    });
    
    console.log('=== FIN DEBUG CARRERAS ===');
  }

  // ========== M√âTODOS PARA DESCARGAR DATOS ==========
  downloadInstitutions(format: 'json' | 'excel' | 'txt'): void {
    if (this.institutions.length === 0) {
      this.showError('No hay instituciones para descargar');
      return;
    }

    this.showInfo(`Generando archivo ${format.toUpperCase()}...`);

    const currentUserId = this.currentUser?.id;
    
    if (!currentUserId) {
      this.showError('No se pudo identificar el usuario');
      return;
    }

    console.log('üîë Usando userId para descarga:', currentUserId);

    const downloadObservable = format === 'json' 
      ? this.institutionService.downloadInstitutionsJSONWithUserId(currentUserId)
      : format === 'excel'
      ? this.institutionService.downloadInstitutionsExcelWithUserId(currentUserId)
      : this.institutionService.downloadInstitutionsTXTWithUserId(currentUserId);

    downloadObservable.subscribe({
      next: (blob: Blob) => {
        const timestamp = new Date().getTime();
        const filename = `instituciones_${timestamp}.${format === 'excel' ? 'xlsx' : format}`;
        
        this.institutionService.handleDownload(blob, filename);
        this.showSuccess(`‚úÖ Archivo ${format.toUpperCase()} descargado exitosamente`);
        
        console.log(`üìÅ Archivo descargado: ${filename}`);
        console.log(`üìä Instituciones incluidas: ${this.institutions.length}`);
      },
      error: (error) => {
        console.error(`‚ùå Error descargando ${format}:`, error);
        this.showError(`Error al descargar archivo ${format.toUpperCase()}`);
      }
    });
  }

  downloadCompleteData(format: 'json' | 'excel'): void {
    if (this.institutions.length === 0 && this.careers.length === 0) {
      this.showError('No hay datos para descargar');
      return;
    }

    this.showInfo(`Generando reporte completo en ${format.toUpperCase()}...`);

    const currentUserId = this.currentUser?.id;
    
    if (!currentUserId) {
      this.showError('No se pudo identificar el usuario');
      return;
    }

    console.log('üîë Usando userId para descarga completa:', currentUserId);

    const downloadObservable = format === 'json' 
      ? this.institutionService.downloadCompleteDataJSONWithUserId(currentUserId)
      : this.institutionService.downloadCompleteDataExcelWithUserId(currentUserId);

    downloadObservable.subscribe({
      next: (blob: Blob) => {
        const timestamp = new Date().getTime();
        const filename = `reporte_completo_${timestamp}.${format === 'excel' ? 'xlsx' : format}`;
        
        this.institutionService.handleDownload(blob, filename);
        this.showSuccess(`‚úÖ Reporte completo ${format.toUpperCase()} descargado exitosamente`);
        
        console.log(`üìÅ Archivo descargado: ${filename}`);
        console.log(`üìä Instituciones incluidas: ${this.institutions.length}`);
        console.log(`üéì Carreras incluidas: ${this.careers.length}`);
      },
      error: (error) => {
        console.error(`‚ùå Error descargando reporte completo ${format}:`, error);
        this.showError(`Error al descargar reporte completo ${format.toUpperCase()}`);
      }
    });
  }

  onDownloadFormatSelected(format: string): void {
    if (format === 'json' || format === 'excel' || format === 'txt') {
      this.downloadInstitutions(format);
    }
  }

  onDownloadCompleteFormatSelected(format: string): void {
    if (format === 'json' || format === 'excel') {
      this.downloadCompleteData(format);
    }
  }

  // ========== DESCARGAR ARCHIVO DE EJEMPLO EXCEL ==========
  downloadExampleExcel(): void {
    this.showInfo('Descargando archivo de ejemplo...');
    
    this.institutionService.downloadExampleExcelFile().subscribe({
      next: (blob: Blob) => {
        this.institutionService.handleDownload(blob, 'ejemplo_formato_instituciones.xlsx');
        this.showSuccess('‚úÖ Archivo de ejemplo descargado exitosamente');
      },
      error: (error) => {
        console.error('‚ùå Error descargando ejemplo:', error);
        this.showError('Error al descargar archivo de ejemplo');
      }
    });
  }

  // ========== M√âTODO PARA MOSTRAR INFORMACI√ìN DE ROL ==========
  getRoleBadgeClass(): string {
    return this.isAdminUser ? 'bg-danger' : 'bg-info';
  }

  getRoleText(): string {
    return this.isAdminUser ? 'Administrador' : 'Usuario Normal';
  }

  getRoleDescription(): string {
    if (this.isAdminUser) {
      return 'Tienes acceso completo a todas las instituciones y carreras del sistema. Puedes crear, editar y eliminar cualquier registro.';
    } else {
      return 'Puedes registrar una instituci√≥n educativa y gestionar sus carreras. Contacta al administrador si necesitas m√°s permisos.';
    }
  }

  // ========== M√âTODO PARA ACTUALIZAR ESTAD√çSTICAS ==========
  updateDashboardStats(): void {
    this.dashboardStats = {
      totalInstitutions: this.institutions.length,
      totalCareers: this.careers.length,
      institutionsAddedByUser: this.institutions.filter(inst => inst.user_id === this.currentUser?.id).length,
      lastUpdated: new Date()
    };
  }

  // ========== M√âTODO PARA VER M√âTRICAS DE CARRERA ==========
  verMetricasCarrera(carreraNombre: string): void {
    const carrera = this.carrerasDisponibles.find(c => c.nombre === carreraNombre);
    if (carrera) {
      this.showInfo(`
        Carrera: ${carrera.nombre}
        Poblaci√≥n Esperada: ${carrera.poblacionEsperada}
        Poblaci√≥n Real: ${carrera.poblacionReal}
        Porcentaje de Cumplimiento: ${this.getPorcentajeCarrera(carrera)}%
      `);
    }
  }
}
import { Component, OnInit, OnDestroy, ViewChild, ElementRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { AuthService } from '../../services/auth.service';
import { Router } from '@angular/router';
import { Subscription } from 'rxjs';
import { User } from '../../models/user.model';
@Component({
  selector: 'app-header',
  standalone: true,
  imports: [CommonModule, RouterModule, ReactiveFormsModule],
  templateUrl: './header.html',
  styleUrls: ['./header.css']
})
export class HeaderComponent implements OnInit, OnDestroy {
  @ViewChild('userDropdown') userDropdown!: ElementRef;

  isLoggedIn = false;
  currentUser: User | null = null;
  isAdmin = false;

  // Formulario de perfil
  profileForm: FormGroup;
  profileSubmitted = false;
  updatingProfile = false;
  avatarPreview: string | null = null;
  selectedAvatar: File | null = null;
  profileSuccessMessage = '';
  profileErrorMessage = '';

  private userSubscription: Subscription | null = null;

  constructor(
    private authService: AuthService,
    private router: Router,
    private formBuilder: FormBuilder
  ) {
    // Formulario de perfil
    this.profileForm = this.formBuilder.group({
      username: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]],
      nombreCompleto: [''],
      telefono: [''],
      institucion: [''],
      currentPassword: [''],
      newPassword: [''],
      confirmPassword: ['']
    }, { validators: this.passwordMatchValidator });
  }

  ngOnInit(): void {
    // Sincronizar estado inicial de autenticaci√≥n y usuario
    this.checkInitialAuthState();
    this.userSubscription = this.authService.currentUser.subscribe({
      next: (user: any) => {
        this.updateUserState(user);
      },
      error: (error: any) => {
        console.error('Error obteniendo usuario:', error);
      }
    });
  }
  

  private checkInitialAuthState(): void {
    const user = this.authService.currentUserValue;
    const token = this.authService.getToken();

    // Estado inicial
    this.updateUserState(user);

    // Si hay token pero no hay usuario, refrescar datos
    if (token && !user) {
      this.authService.refreshUserData().subscribe({
        next: (resp) => {
          if (resp && resp.user) {
            this.updateUserState(resp.user);
          }
        },
        error: (err) => {
          console.error('Error refrescando datos de usuario:', err);
        }
      });
    }
  }

  private updateUserState(user: User | null): void {
    this.currentUser = user;
    this.isLoggedIn = !!user && this.authService.isAuthenticated();
    this.isAdmin = !!user && user.role === 'admin';
    // Opcional: puedes dejar el log para debug
    // console.log('üîÑ Estado actualizado del header:', { isLoggedIn: this.isLoggedIn, currentUser: this.currentUser, isAdmin: this.isAdmin });
  }

  ngOnDestroy(): void {
    if (this.userSubscription) {
      this.userSubscription.unsubscribe();
    }
  }

  // Validador para contrase√±as
  private passwordMatchValidator(g: FormGroup) {
    const newPassword = g.get('newPassword')?.value;
    const confirmPassword = g.get('confirmPassword')?.value;

    if (!newPassword && !confirmPassword) {
      return null;
    }

    return newPassword === confirmPassword ? null : { passwordMismatch: true };
  }

  // Getter para el formulario de perfil
  get pf() { return this.profileForm.controls; }

  // Obtener nombre display del rol
  getRoleDisplayName(role: string): string {
    const roles: { [key: string]: string } = {
      'admin': 'Administrador',
      'user': 'Usuario',
      'superadmin': 'Super Administrador'
    };
    return roles[role] || 'Usuario';
  }

  // Cerrar dropdown manualmente
  closeDropdown(): void {
    if (this.userDropdown) {
      const dropdownElement = this.userDropdown.nativeElement;
      const dropdown = (window as any).bootstrap.Dropdown.getInstance(dropdownElement);
      if (dropdown) {
        dropdown.hide();
      }
    }
  }

  // Abrir modal de edici√≥n de perfil
  openEditProfile(): void {
    console.log('üìù Abriendo modal de edici√≥n de perfil...');
    this.closeDropdown(); // Cerrar dropdown al abrir modal

    if (!this.currentUser) {
      console.error('‚ùå No hay usuario actual para editar');
      return;
    }

    // Llenar el formulario con los datos actuales del usuario
    this.profileForm.patchValue({
      username: this.currentUser.username,
      email: this.currentUser.email,
      nombreCompleto: this.currentUser.nombreCompleto || '',
      telefono: this.currentUser.telefono || '',
      institucion: this.currentUser.institucion || ''
    });

    this.avatarPreview = this.currentUser.avatar || null;
    this.selectedAvatar = null;
    this.profileSubmitted = false;
    this.profileSuccessMessage = '';
    this.profileErrorMessage = '';

    console.log('üìã Formulario preparado con datos:', this.profileForm.value);

    // Abrir el modal usando Bootstrap
    const modalElement = document.getElementById('headerEditProfileModal');
    if (modalElement) {
      const modal = new (window as any).bootstrap.Modal(modalElement);
      modal.show();
      console.log('‚úÖ Modal abierto correctamente');
    } else {
      console.error('‚ùå No se encontr√≥ el elemento del modal');
    }
  }

  // Manejar selecci√≥n de avatar
 // En el m√©todo onAvatarSelected
onAvatarSelected(event: any): void {
    const file = event.target.files[0];
    if (file) {
        const validTypes = ['image/jpeg', 'image/png', 'image/gif'];

        if (!validTypes.includes(file.type)) {
            this.profileErrorMessage = 'Por favor, selecciona una imagen v√°lida (JPG, PNG, GIF)';
            return;
        }

        // Reducir l√≠mite de 2MB a 500KB para evitar problemas con base64
        if (file.size > 500 * 1024) { // 500KB m√°ximo
            this.profileErrorMessage = 'La imagen es demasiado grande. M√°ximo 500KB permitido.';
            return;
        }

        this.selectedAvatar = file;
        this.profileErrorMessage = '';

        const reader = new FileReader();
        reader.onload = (e: any) => {
            this.avatarPreview = e.target.result;
            
            // Verificar tama√±o del base64 resultante
            const base64Length = e.target.result.length;
            console.log(`üìè Tama√±o base64: ${base64Length} caracteres`);
            
            // MySQL TEXT: 65,535 caracteres
            // MySQL MEDIUMTEXT: 16,777,215 caracteres
            // MySQL LONGTEXT: 4,294,967,295 caracteres
            if (base64Length > 16000000) {
                this.profileErrorMessage = 'La imagen es demasiado grande despu√©s de conversi√≥n. Por favor, elige una imagen m√°s peque√±a.';
                this.avatarPreview = null;
                this.selectedAvatar = null;
            }
        };
        reader.readAsDataURL(file);
    }
}

  // Eliminar avatar
  removeAvatar(): void {
    this.selectedAvatar = null;
    this.avatarPreview = null;
  }

  // Actualizar perfil
// ... imports y c√≥digo anterior ...

// Actualizar perfil
updateProfile(): void {
    this.profileSubmitted = true;
    this.profileSuccessMessage = '';
    this.profileErrorMessage = '';

    if (this.profileForm.invalid) {
        console.log('‚ùå Formulario inv√°lido');
        return;
    }

    this.updatingProfile = true;

    // Preparar datos para enviar
    const formData = this.profileForm.value;
    const profileData: any = {
        username: formData.username,
        email: formData.email,
        nombreCompleto: formData.nombreCompleto || '',
        telefono: formData.telefono || '',
        institucion: formData.institucion || '',
        avatar: this.avatarPreview || this.currentUser?.avatar || null
    };

    // Si se est√° subiendo una nueva imagen
    if (this.selectedAvatar && this.avatarPreview) {
        // Si el avatar es una imagen base64 (menos de 2MB), enviar directamente
        if (this.avatarPreview.startsWith('data:image')) {
            profileData.avatar = this.avatarPreview;
        }
    }

    // Si se proporcionaron contrase√±as, agregarlas
    if (formData.currentPassword && formData.newPassword) {
        profileData.currentPassword = formData.currentPassword;
        profileData.newPassword = formData.newPassword;
    }

    console.log('üì§ Enviando datos del perfil:', profileData);

    // Usar el servicio de autenticaci√≥n para actualizar el perfil
    this.authService.updateProfile(profileData).subscribe({
        next: (response) => {
            this.updatingProfile = false;
            console.log('‚úÖ Respuesta de actualizaci√≥n:', response);

            if (response.success) {
                this.profileSuccessMessage = 'Perfil actualizado exitosamente';

                // Actualizar datos locales del usuario
                if (response.user) {
                    this.currentUser = response.user;
                    this.authService.saveUserData(response.user);
                }

                // Limpiar formulario
                this.profileForm.patchValue({
                    currentPassword: '',
                    newPassword: '',
                    confirmPassword: ''
                });

                // Cerrar el modal despu√©s de 2 segundos
                setTimeout(() => {
                    this.closeModal();
                    
                    // Refrescar la p√°gina para asegurar que todos los cambios se vean
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                }, 2000);
            } else {
                this.profileErrorMessage = response.message || 'Error al actualizar el perfil';
            }
        },
        error: (error) => {
            this.updatingProfile = false;
            console.error('‚ùå Error actualizando perfil:', error);
            
            if (error.status === 401) {
                this.profileErrorMessage = 'La contrase√±a actual es incorrecta';
            } else if (error.status === 400) {
                this.profileErrorMessage = error.error?.message || 'Error en los datos enviados';
            } else {
                this.profileErrorMessage = 'Error de conexi√≥n al actualizar el perfil';
            }
        }
    });
}

// ... resto del c√≥digo ...

  private closeModal(): void {
    const modalElement = document.getElementById('headerEditProfileModal');
    if (modalElement) {
      const modal = (window as any).bootstrap.Modal.getInstance(modalElement);
      if (modal) {
        modal.hide();
      }
    }
  }

  // Cerrar sesi√≥n
  logout(): void {
    console.log('üö™ Intentando cerrar sesi√≥n...');
    this.closeDropdown(); // Cerrar dropdown al hacer logout

    if (confirm('¬øEst√°s seguro de que deseas cerrar sesi√≥n?')) {
      this.authService.logout();
      this.router.navigate(['/login']);
    }
  }
}


import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router, ActivatedRoute } from '@angular/router';
import { RouterModule } from '@angular/router';
import { AuthService } from '../../services/auth.service';
import { LoginRequest } from '../../models/user.model';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterModule],
  templateUrl: './login.html',
  styleUrls: ['./login.css']
})
export class LoginComponent implements OnInit {
  loginForm: FormGroup;
  loading = false;
  submitted = false;
  error = '';
  returnUrl = '/dashboard';

  demoUsers = [
    { email: 'admin@tec.com', password: 'password', role: 'Administrador' },
    { email: 'user@tec.com', password: 'password', role: 'Usuario' }
  ];

  constructor(
    private fb: FormBuilder,
    private router: Router,
    private route: ActivatedRoute,
    private authService: AuthService
  ) {
    this.loginForm = this.fb.group({
      email: ['', [Validators.required, Validators.email]],
      password: ['', Validators.required]
    });
  }

  ngOnInit(): void {
    this.returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/dashboard';

    // ‚úÖ CORREGIDO: Verificar si el usuario ya est√° autenticado
    if (this.authService.isAuthenticated()) {
      console.log('‚úÖ Usuario ya autenticado, redirigiendo a:', this.returnUrl);
      this.router.navigate([this.returnUrl]);
    }
  }

  get f() {
    return this.loginForm.controls;
  }

  onSubmit(): void {
    this.submitted = true;
    this.error = '';

    if (this.loginForm.invalid) {
      return;
    }

    this.loading = true;

    // ‚úÖ CORRECCI√ìN: Usar directamente los valores del formulario
    const credentials: LoginRequest = {
      email: this.f['email'].value,
      password: this.f['password'].value
    };

    console.log('üîê Intentando login con:', credentials);

    this.authService.login(credentials.email, credentials.password)
      .subscribe({
        next: (response) => {
          this.loading = false;
          console.log('‚úÖ Respuesta de login:', response);

          if (response.success) {
            console.log('‚úÖ Usuario autenticado:', response.user);
            this.router.navigate([this.returnUrl]);
          } else {
            this.error = response.message || 'Error al iniciar sesi√≥n';
            console.error('‚ùå Error en login:', this.error);
          }
        },
        error: (error) => {
          this.loading = false;
          this.error = error.error?.message || 'Error de conexi√≥n con el servidor';
          console.error('‚ùå Login error:', error);
        }
      });
  }

  fillDemoCredentials(user: any): void {
    this.loginForm.patchValue({
      email: user.email,
      password: user.password
    });
    this.error = '';
  }
}
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { AuthService } from '../../services/auth.service';
import { CaptchaService } from '../../services/captcha';
import { RegisterRequestWithRole, AuthResponse } from '../../models/user.model';

@Component({
  selector: 'app-register',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterModule],
  templateUrl: './register.html',
  styleUrls: ['./register.css']
})
export class RegisterComponent implements OnInit {
  registerForm: FormGroup;
  loading = false;
  submitted = false;
  error = '';
  success = false;
  generatedCredentials: { username: string, password: string } | null = null;
  captchaText: string = '';
  showAdminField = false;
  showWorkerNumberField = false;

  constructor(
    private formBuilder: FormBuilder,
    private router: Router,
    private authService: AuthService,
    private captchaService: CaptchaService
  ) {
    this.registerForm = this.formBuilder.group({
      email: ['', [Validators.required, Validators.email]],
      password: ['', [Validators.required, Validators.minLength(6)]],
      confirmPassword: ['', Validators.required],
      nombreCompleto: ['', Validators.required],
      telefono: ['', Validators.required],
      institucion: ['', Validators.required],
      role: ['user'],
      adminKey: [''],
      numeroTrabajador: [''],
      captcha: ['', [Validators.required, Validators.minLength(6)]],
      terms: [false, Validators.requiredTrue]
    }, {
      validators: [this.passwordMatchValidator, this.validateAdminFields]
    });
  }

  ngOnInit(): void {
    if (this.authService.isAuthenticated()) {
      this.router.navigate(['/dashboard']);
    }
    this.generateNewCaptcha();
    
    // Observar cambios en el campo role
    this.registerForm.get('role')?.valueChanges.subscribe(value => {
      this.showAdminField = value === 'admin';
      this.showWorkerNumberField = value === 'admin';
      
      if (value === 'admin') {
        this.registerForm.get('adminKey')?.setValidators([Validators.required]);
        this.registerForm.get('numeroTrabajador')?.setValidators([Validators.required]);
      } else {
        this.registerForm.get('adminKey')?.clearValidators();
        this.registerForm.get('numeroTrabajador')?.clearValidators();
      }
      
      this.registerForm.get('adminKey')?.updateValueAndValidity();
      this.registerForm.get('numeroTrabajador')?.updateValueAndValidity();
    });
  }

  get f() { return this.registerForm.controls; }

  // Validador personalizado para confirmar contrase√±a
  passwordMatchValidator(form: FormGroup) {
    const password = form.get('password');
    const confirmPassword = form.get('confirmPassword');
    
    if (password && confirmPassword && password.value !== confirmPassword.value) {
      confirmPassword.setErrors({ passwordMismatch: true });
    } else {
      confirmPassword?.setErrors(null);
    }
    return null;
  }

  // Validador para campos de admin
  validateAdminFields(form: FormGroup) {
    const role = form.get('role')?.value;
    const adminKey = form.get('adminKey')?.value;
    const numeroTrabajador = form.get('numeroTrabajador')?.value;
    
    if (role === 'admin') {
      const errors: any = {};
      
      if (!adminKey) {
        form.get('adminKey')?.setErrors({ required: true });
        errors['adminKey'] = true;
      } else {
        // Verificar clave secreta
        const ADMIN_SECRET = 'admin123TEC'; // Deber√≠a estar en environment
        if (adminKey !== ADMIN_SECRET) {
          form.get('adminKey')?.setErrors({ adminKeyInvalid: true });
          errors['adminKey'] = true;
        }
      }
      
      if (!numeroTrabajador) {
        form.get('numeroTrabajador')?.setErrors({ required: true });
        errors['numeroTrabajador'] = true;
      }
      
      return Object.keys(errors).length > 0 ? errors : null;
    }
    
    return null;
  }

  generateNewCaptcha(): void {
    this.captchaText = this.captchaService.generateCaptcha();
    this.registerForm.patchValue({ captcha: '' });
  }

  toggleAdminField(event: any): void {
    const isChecked = event.target.checked;
    this.showAdminField = isChecked;
    this.showWorkerNumberField = isChecked;
    
    if (isChecked) {
      this.registerForm.patchValue({ role: 'admin' });
      this.registerForm.get('adminKey')?.setValidators([Validators.required]);
      this.registerForm.get('numeroTrabajador')?.setValidators([Validators.required]);
    } else {
      this.registerForm.patchValue({ 
        role: 'user',
        adminKey: '',
        numeroTrabajador: ''
      });
      this.registerForm.get('adminKey')?.clearValidators();
      this.registerForm.get('numeroTrabajador')?.clearValidators();
    }
    
    this.registerForm.get('adminKey')?.updateValueAndValidity();
    this.registerForm.get('numeroTrabajador')?.updateValueAndValidity();
  }

  onSubmit(): void {
    this.submitted = true;
    this.error = '';

    if (this.registerForm.invalid) {
      // Marcar todos los campos como tocados para mostrar errores
      Object.keys(this.f).forEach(key => {
        const control = this.f[key];
        control.markAsTouched();
      });
      return;
    }

    if (!this.captchaService.validateCaptcha(this.f['captcha'].value)) {
      this.error = 'El c√≥digo de verificaci√≥n es incorrecto. Intenta nuevamente.';
      this.generateNewCaptcha();
      return;
    }

    this.loading = true;

    const userData: RegisterRequestWithRole = {
      email: this.f['email'].value,
      password: this.f['password'].value,
      nombreCompleto: this.f['nombreCompleto'].value,
      telefono: this.f['telefono'].value,
      institucion: this.f['institucion'].value,
      role: this.f['role'].value
    };

    // Agregar campos espec√≠ficos de admin si es necesario
    if (userData.role === 'admin') {
      userData.adminKey = this.f['adminKey'].value;
      userData.numeroTrabajador = this.f['numeroTrabajador'].value;
    }

    console.log('üìù Datos de registro enviados:', userData);

    this.authService.register(userData)
      .subscribe({
        next: (response: AuthResponse) => {
          this.loading = false;
          console.log('‚úÖ Respuesta de registro:', response);

          if (response.success && response.user && response.token) {
            this.generatedCredentials = {
              username: response.user.username,
              password: userData.password
            };
            this.success = true;
            
            console.log('‚úÖ Registro exitoso. Usuario:', response.user.role);
            
            // Auto-login despu√©s del registro
            this.autoLoginAfterRegister();
          } else {
            this.error = response.message || 'Error al registrar usuario';
          }
        },
        error: (error) => {
          this.loading = false;
          console.error('‚ùå Error en registro:', error);
          
          if (error.error && error.error.message) {
            this.error = error.error.message;
          } else if (error.status === 400) {
            this.error = 'El usuario con este email ya existe';
          } else if (error.status === 0) {
            this.error = 'Error de conexi√≥n con el servidor. Verifica tu conexi√≥n.';
          } else {
            this.error = 'Error interno del servidor. Intenta nuevamente.';
          }
        }
      });
  }

  autoLoginAfterRegister(): void {
    if (this.generatedCredentials) {
      this.loading = true;
      this.authService.login(this.generatedCredentials.username, this.generatedCredentials.password)
        .subscribe({
          next: (response) => {
            this.loading = false;
            if (response.success) {
              this.router.navigate(['/dashboard']);
            } else {
              this.router.navigate(['/login']);
            }
          },
          error: (error) => {
            this.loading = false;
            this.router.navigate(['/login']);
          }
        });
    } else {
      this.router.navigate(['/login']);
    }
  }

  goToLogin(): void {
    this.router.navigate(['/login']);
  }
}